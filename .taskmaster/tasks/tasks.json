{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Go Project and Dependencies",
        "description": "Set up the Go project structure with module initialization and configure cross-platform build targets for MacOS and Windows 11",
        "details": "Create project directory structure:\n- cmd/mixcloud-updater/main.go (entry point)\n- internal/config/ (configuration management)\n- internal/cue/ (CUE file parsing)\n- internal/mixcloud/ (API integration)\n- internal/filter/ (content filtering)\n- internal/logger/ (logging utilities)\n\nInitialize go.mod with module name 'github.com/nowwaveradio/mixcloud-updater'\n\nAdd minimal dependencies:\n- github.com/BurntSushi/toml for TOML parsing\n- golang.org/x/oauth2 for OAuth 2.0 handling\n\nCreate Makefile with cross-compilation targets:\n```makefile\nbuild-windows:\n\tGOOS=windows GOARCH=amd64 go build -o bin/mixcloud-updater.exe ./cmd/mixcloud-updater\n\nbuild-macos:\n\tGOOS=darwin GOARCH=amd64 go build -o bin/mixcloud-updater-macos ./cmd/mixcloud-updater\n```",
        "testStrategy": "Verify project structure is created correctly, go.mod is initialized with proper module name, dependencies are installable via 'go mod download', and both cross-compilation targets produce valid executables without errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create project directory structure and initialize Go module",
            "description": "Set up the base directory structure for the Go project and initialize the Go module with the specified module name",
            "dependencies": [],
            "details": "Create the following directories:\n- cmd/mixcloud-updater/ (for main.go entry point)\n- internal/config/ (configuration management)\n- internal/cue/ (CUE file parsing)\n- internal/mixcloud/ (API integration)\n- internal/filter/ (content filtering)\n- internal/logger/ (logging utilities)\n- bin/ (for compiled binaries)\n\nRun 'go mod init github.com/nowwaveradio/mixcloud-updater' to create go.mod file",
            "status": "done",
            "testStrategy": "Verify directory structure exists and go.mod contains correct module name"
          },
          {
            "id": 2,
            "title": "Add core dependencies to go.mod",
            "description": "Add the required external dependencies for TOML parsing and OAuth 2.0 handling",
            "dependencies": [
              1
            ],
            "details": "Run the following commands:\n- go get github.com/BurntSushi/toml@latest\n- go get golang.org/x/oauth2@latest\n\nEnsure go.mod and go.sum are updated with the correct versions",
            "status": "done",
            "testStrategy": "Run 'go mod verify' to ensure dependencies are correctly downloaded and verified"
          },
          {
            "id": 3,
            "title": "Create main.go entry point with basic structure",
            "description": "Implement the main.go file in cmd/mixcloud-updater with a basic application skeleton",
            "dependencies": [
              1
            ],
            "details": "Create cmd/mixcloud-updater/main.go with:\n- Package main declaration\n- Import statements for future modules\n- Basic main() function with placeholder logic\n- Add comments for future implementation areas\n- Include basic command-line flag parsing setup",
            "status": "done",
            "testStrategy": "Run 'go build ./cmd/mixcloud-updater' to verify the entry point compiles successfully"
          },
          {
            "id": 4,
            "title": "Create Makefile with cross-compilation targets",
            "description": "Set up a Makefile with build targets for Windows and MacOS cross-compilation",
            "dependencies": [
              3
            ],
            "details": "Create Makefile in project root with:\n- build-windows target: GOOS=windows GOARCH=amd64 go build -o bin/mixcloud-updater.exe ./cmd/mixcloud-updater\n- build-macos target: GOOS=darwin GOARCH=amd64 go build -o bin/mixcloud-updater-macos ./cmd/mixcloud-updater\n- build-all target that runs both\n- clean target to remove bin/ directory\n- Add .PHONY declarations for all targets",
            "status": "done",
            "testStrategy": "Run 'make build-windows' and 'make build-macos' to verify both targets produce binaries in bin/ directory"
          },
          {
            "id": 5,
            "title": "Create placeholder files for internal packages",
            "description": "Add placeholder Go files in each internal package directory to establish the package structure",
            "dependencies": [
              1
            ],
            "details": "Create the following files with basic package declarations and doc comments:\n- internal/config/config.go (package config)\n- internal/cue/parser.go (package cue)\n- internal/mixcloud/client.go (package mixcloud)\n- internal/filter/filter.go (package filter)\n- internal/logger/logger.go (package logger)\n\nEach file should contain package declaration, package documentation comment, and a TODO comment for future implementation",
            "status": "done",
            "testStrategy": "Run 'go build ./...' from project root to ensure all packages are valid and compile"
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Configuration Management",
        "description": "Create TOML configuration parser and management system for loading station settings, OAuth credentials, and filtering rules",
        "details": "Implement config package in internal/config/:\n\n```go\ntype Config struct {\n    Station struct {\n        Name             string `toml:\"name\"`\n        MixcloudUsername string `toml:\"mixcloud_username\"`\n    } `toml:\"station\"`\n    \n    OAuth struct {\n        ClientID     string `toml:\"client_id\"`\n        ClientSecret string `toml:\"client_secret\"`\n        AccessToken  string `toml:\"access_token\"`\n        RefreshToken string `toml:\"refresh_token\"`\n    } `toml:\"oauth\"`\n    \n    Filtering struct {\n        ExcludedArtists       []string `toml:\"excluded_artists\"`\n        ExcludedTitles        []string `toml:\"excluded_titles\"`\n        ExcludedArtistPatterns []string `toml:\"excluded_artist_patterns\"`\n        ExcludedTitlePatterns  []string `toml:\"excluded_title_patterns\"`\n    } `toml:\"filtering\"`\n    \n    Paths struct {\n        CueFileDirectory string `toml:\"cue_file_directory\"`\n    } `toml:\"paths\"`\n}\n```\n\nImplement LoadConfig() function that:\n- Accepts config file path as parameter\n- Uses BurntSushi/toml to parse file\n- Validates required fields are present\n- Returns error for missing/invalid config",
        "testStrategy": "Create test TOML files with valid and invalid configurations, verify parser correctly loads all fields, test error handling for missing required fields, validate that sensitive OAuth credentials are properly loaded without logging",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Config Structure and Types",
            "description": "Create the config package structure and define all necessary types including Config struct with nested Station, OAuth, Filtering, and Paths structs",
            "dependencies": [],
            "details": "Create internal/config/config.go file. Define the Config struct with proper TOML tags for all fields. Ensure struct fields match the expected TOML structure exactly. Include any additional types needed for configuration management.",
            "status": "done",
            "testStrategy": "Write unit tests to verify struct marshaling/unmarshaling with sample TOML data"
          },
          {
            "id": 2,
            "title": "Implement TOML Parsing Logic",
            "description": "Implement the core LoadConfig function that reads and parses TOML configuration files using the BurntSushi/toml library",
            "dependencies": [
              1
            ],
            "details": "Create LoadConfig(filepath string) (*Config, error) function. Use os.ReadFile to read the config file, then toml.Unmarshal to parse into Config struct. Handle file read errors and parsing errors appropriately. Return populated Config struct on success.",
            "status": "done",
            "testStrategy": "Create test fixtures with valid and invalid TOML files. Test parsing success cases and error handling for malformed TOML"
          },
          {
            "id": 3,
            "title": "Add Configuration Validation",
            "description": "Implement validation logic to ensure all required fields are present and contain valid values after parsing",
            "dependencies": [
              2
            ],
            "details": "Create a Validate() method on Config struct. Check that Station.Name, Station.MixcloudUsername, OAuth.ClientID, and OAuth.ClientSecret are not empty. Validate that Paths.CueFileDirectory exists as a directory. Return descriptive errors for each validation failure.",
            "status": "done",
            "testStrategy": "Test validation with configs missing required fields, empty values, and invalid directory paths"
          },
          {
            "id": 4,
            "title": "Implement Default Values and Config Merging",
            "description": "Add support for default configuration values and ability to merge partial configs with defaults",
            "dependencies": [
              3
            ],
            "details": "Create DefaultConfig() function that returns a Config with sensible defaults (e.g., empty slices for filtering arrays, current directory for paths). Modify LoadConfig to merge loaded values with defaults, preserving any explicitly set values from the TOML file.",
            "status": "done",
            "testStrategy": "Test that defaults are applied when fields are missing, and that explicit values override defaults"
          },
          {
            "id": 5,
            "title": "Add Environment Variable Override Support",
            "description": "Implement functionality to override configuration values using environment variables for sensitive data like OAuth tokens",
            "dependencies": [
              4
            ],
            "details": "Create ApplyEnvironmentOverrides() method that checks for environment variables like NWRMIXCLOUD_OAUTH_ACCESS_TOKEN, NWRMIXCLOUD_OAUTH_REFRESH_TOKEN, etc. Override corresponding config values if env vars are set. Call this after loading from TOML but before validation.",
            "status": "done",
            "testStrategy": "Test with various environment variable combinations, ensuring they properly override TOML values"
          }
        ]
      },
      {
        "id": 3,
        "title": "Build CUE File Parser",
        "description": "Implement parser for standard CUE sheet format files generated by Myriad play-out software to extract track metadata",
        "details": "Create cue package in internal/cue/ with Track struct:\n\n```go\ntype Track struct {\n    Index     int\n    StartTime string  // MM:SS format\n    Artist    string\n    Title     string\n    Genre     string  // if available\n}\n\ntype CueSheet struct {\n    Title  string\n    Date   string\n    Tracks []Track\n}\n```\n\nImplement ParseCueFile() that:\n- Reads CUE file line by line\n- Parses TRACK, PERFORMER, TITLE, and INDEX commands\n- Handles multi-line quoted strings\n- Converts INDEX 01 timestamps to MM:SS format\n- Supports both single-file and multi-file CUE formats\n- Returns parsed CueSheet struct\n\nHandle common CUE commands:\n- REM GENRE for genre information\n- FILE for audio file references\n- TRACK with format \"TRACK 01 AUDIO\"\n- Proper handling of quoted strings with spaces",
        "testStrategy": "Test with actual Myriad-generated CUE files, verify parsing of tracks with special characters in titles/artists, test edge cases like empty tracks, malformed timestamps, and 4-hour show files with 100+ tracks",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CUE Package Structure and Data Models",
            "description": "Set up the cue package directory structure and define the Track and CueSheet structs with proper field types and tags",
            "dependencies": [],
            "details": "Create internal/cue/ directory. Define Track struct with Index (int), StartTime (string for MM:SS format), Artist, Title, and Genre fields. Define CueSheet struct with Title, Date, and Tracks slice. Add JSON tags for serialization. Include helper methods like (t Track) String() for debugging.",
            "status": "done",
            "testStrategy": "Create unit tests to verify struct initialization and basic field access patterns"
          },
          {
            "id": 2,
            "title": "Implement CUE File Reader and Line Parser",
            "description": "Build the core file reading logic that processes CUE files line by line and handles different line formats",
            "dependencies": [
              1
            ],
            "details": "Implement a lineParser that reads the CUE file using bufio.Scanner, strips BOM if present, handles Windows/Unix line endings, and identifies command types (REM, FILE, TRACK, PERFORMER, TITLE, INDEX). Create a parseLine function that returns command type and parameters. Handle line continuations for multi-line quoted strings.",
            "status": "done",
            "testStrategy": "Test with sample CUE files containing various line endings, quoted strings with spaces, and edge cases like empty lines or comments"
          },
          {
            "id": 3,
            "title": "Parse Track-Level Commands and Build Track Objects",
            "description": "Implement parsing logic for TRACK, PERFORMER, TITLE, and INDEX commands to populate Track structs",
            "dependencies": [
              2
            ],
            "details": "Create parseTrack function that maintains state for current track being parsed. Handle TRACK command to initialize new Track with index. Parse PERFORMER and TITLE commands, supporting both track-level and album-level (before first TRACK). Parse INDEX 01 commands and convert frame-based time (MM:SS:FF) to MM:SS format by dropping frames. Handle quoted strings properly.",
            "status": "done",
            "testStrategy": "Test parsing of individual tracks with various metadata combinations, verify correct time format conversion, test quote handling"
          },
          {
            "id": 4,
            "title": "Implement Album-Level Metadata and Special Commands",
            "description": "Parse album-level metadata including REM commands, FILE references, and global PERFORMER/TITLE",
            "dependencies": [
              3
            ],
            "details": "Parse REM GENRE commands and store in appropriate track or album level. Handle FILE commands for both single-file and multi-file CUE formats, storing file references. Parse global PERFORMER and TITLE that appear before first TRACK command. Support REM DATE and other common REM fields. Maintain parsing context to differentiate between album and track level commands.",
            "status": "done",
            "testStrategy": "Test with CUE files containing various REM commands, multiple FILE entries, and mixed album/track metadata"
          },
          {
            "id": 5,
            "title": "Create ParseCueFile Function and Error Handling",
            "description": "Implement the main ParseCueFile function that orchestrates the parsing process and provides comprehensive error handling",
            "dependencies": [
              4
            ],
            "details": "Create ParseCueFile(filename string) (*CueSheet, error) that opens the file, initializes the parser, and coordinates the parsing process. Add validation for required fields, handle malformed commands gracefully, and provide descriptive error messages with line numbers. Support both absolute and relative file paths. Clean up any partial results on error. Add logging for debugging.",
            "status": "done",
            "testStrategy": "Test with valid and invalid CUE files, verify error messages are helpful, test file not found scenarios, verify memory cleanup on errors"
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Content Filtering Engine",
        "description": "Build filtering system to exclude station IDs, ads, and other non-music content using string matching and regex patterns",
        "details": "Implement filter package in internal/filter/:\n\n```go\ntype Filter struct {\n    excludedArtists       []string\n    excludedTitles        []string\n    excludedArtistRegex   []*regexp.Regexp\n    excludedTitleRegex    []*regexp.Regexp\n}\n\nfunc NewFilter(config *config.Config) (*Filter, error) {\n    // Compile regex patterns from config\n    // Store lowercase versions for case-insensitive matching\n}\n\nfunc (f *Filter) ShouldIncludeTrack(track *cue.Track) bool {\n    // Check string matching (case-insensitive)\n    // Check regex patterns\n    // Return false if any filter matches\n}\n```\n\nImplement filtering logic:\n- Case-insensitive string matching for artist/title\n- Regex pattern matching with proper error handling\n- Combine multiple filter types (string + regex)\n- Log filtered tracks for debugging (INFO level)",
        "testStrategy": "Create test tracks with various station IDs, commercials, and bumpers, verify they are correctly filtered, test regex patterns with edge cases, ensure legitimate tracks are not incorrectly filtered",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Filter Package Structure and Types",
            "description": "Create the filter package directory structure and define the Filter struct with all necessary fields for string and regex-based filtering",
            "dependencies": [],
            "details": "Create internal/filter/filter.go and define the Filter struct with fields for excludedArtists, excludedTitles, excludedArtistRegex, and excludedTitleRegex. Import necessary packages including regexp and the config package. Define the interface methods that will be implemented.",
            "status": "done",
            "testStrategy": "Create filter_test.go with test fixtures for various filter configurations"
          },
          {
            "id": 2,
            "title": "Implement NewFilter Constructor with Config Parsing",
            "description": "Create the NewFilter function that reads configuration and compiles regex patterns with proper error handling",
            "dependencies": [
              1
            ],
            "details": "Implement NewFilter(config *config.Config) (*Filter, error) that reads excluded artists/titles from config, converts string patterns to lowercase for case-insensitive matching, compiles regex patterns from config with error handling for invalid patterns, and returns initialized Filter instance or error if regex compilation fails.",
            "status": "done",
            "testStrategy": "Test with valid and invalid regex patterns, empty configurations, and various config combinations"
          },
          {
            "id": 3,
            "title": "Implement String-Based Filtering Logic",
            "description": "Create helper methods for case-insensitive string matching against excluded artists and titles",
            "dependencies": [
              2
            ],
            "details": "Implement private helper methods like isExcludedByString(artist, title string) bool that converts input to lowercase and checks against pre-lowercased excluded lists. Use strings.Contains or exact matching based on requirements. Ensure efficient lookup for large exclusion lists.",
            "status": "done",
            "testStrategy": "Unit tests with various case combinations, partial matches, and edge cases like empty strings"
          },
          {
            "id": 4,
            "title": "Implement Regex-Based Filtering Logic",
            "description": "Create helper methods for regex pattern matching against track metadata",
            "dependencies": [
              2
            ],
            "details": "Implement private helper methods like isExcludedByRegex(artist, title string) bool that iterates through compiled regex patterns and checks for matches. Handle nil regex slices gracefully. Consider performance implications of multiple regex checks.",
            "status": "done",
            "testStrategy": "Test with complex regex patterns, special characters, and performance benchmarks for multiple patterns"
          },
          {
            "id": 5,
            "title": "Implement ShouldIncludeTrack Method with Logging",
            "description": "Create the main filtering method that combines all filter types and adds debug logging for filtered tracks",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement ShouldIncludeTrack(track *cue.Track) bool that calls string and regex filtering helpers, returns false if any filter matches (track should be excluded), logs filtered tracks at INFO level with reason (which filter matched), and handles nil track gracefully. Ensure the method is efficient as it will be called for every track.",
            "status": "done",
            "testStrategy": "Integration tests with real track data, verify logging output, test filter precedence and combination logic"
          }
        ]
      },
      {
        "id": 5,
        "title": "Develop Mixcloud OAuth 2.0 Client",
        "description": "Implement OAuth 2.0 authentication with automatic token refresh for Mixcloud API integration",
        "details": "Create mixcloud package in internal/mixcloud/:\n\n```go\ntype Client struct {\n    httpClient   *http.Client\n    config       *oauth2.Config\n    token        *oauth2.Token\n    username     string\n}\n\nfunc NewClient(cfg *config.Config) (*Client, error) {\n    oauth2Config := &oauth2.Config{\n        ClientID:     cfg.OAuth.ClientID,\n        ClientSecret: cfg.OAuth.ClientSecret,\n        Endpoint: oauth2.Endpoint{\n            AuthURL:  \"https://www.mixcloud.com/oauth/authorize\",\n            TokenURL: \"https://www.mixcloud.com/oauth/access_token\",\n        },\n    }\n    \n    // Create token from stored credentials\n    // Setup automatic token refresh\n    // Return configured client\n}\n```\n\nImplement token refresh mechanism:\n- Use golang.org/x/oauth2 TokenSource for auto-refresh\n- Update config file with new tokens after refresh\n- Handle refresh errors gracefully\n- Log token refresh events",
        "testStrategy": "Test OAuth client initialization with valid/invalid tokens, verify automatic token refresh works when access token is expired, test API calls with refreshed tokens, ensure config file is updated with new tokens",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Mixcloud Client Structure and Configuration",
            "description": "Set up the basic Client struct and configuration loading for OAuth 2.0 authentication",
            "dependencies": [],
            "details": "Create internal/mixcloud/client.go with Client struct containing httpClient, oauth2.Config, token, and username fields. Implement NewClient constructor that initializes oauth2.Config from the provided config.Config, setting up proper ClientID, ClientSecret, and OAuth endpoints (AuthURL: https://www.mixcloud.com/oauth/authorize, TokenURL: https://www.mixcloud.com/oauth/access_token)\n<info added on 2025-06-29T20:07:25.557Z>\nSuccessfully completed the Client struct and NewClient constructor implementation. The Client struct includes all required fields (httpClient, config, token, username) with proper types. NewClient validates all config parameters before initialization, ensuring ClientID, ClientSecret, and MixcloudUsername are present. OAuth2 configuration correctly uses Mixcloud's endpoints. Added automatic token creation from stored credentials when available in config. Included Show struct with appropriate JSON tags for parsing API responses. Package compiles without errors and is ready for token storage/retrieval implementation.\n</info added on 2025-06-29T20:07:25.557Z>",
            "status": "done",
            "testStrategy": "Unit test NewClient to verify proper initialization of oauth2.Config with mock config values"
          },
          {
            "id": 2,
            "title": "Implement Token Storage and Retrieval",
            "description": "Add methods to store and retrieve OAuth tokens from the configuration file",
            "dependencies": [
              1
            ],
            "details": "Create methods LoadToken() and SaveToken() on the Client struct. LoadToken should read the stored access token and refresh token from config.Config. SaveToken should update the config file with new token values using the config package's update functionality. Handle file I/O errors and ensure thread-safe operations\n<info added on 2025-06-29T20:09:11.552Z>\nSuccessfully implemented LoadToken() and SaveToken() methods for persistent token management.\n\nKey implementation details:\n- Modified Client struct to include *config.Config and configPath fields for direct config access\n- Updated NewClient() signature to require configPath parameter, enabling token persistence\n- LoadToken() returns the stored OAuth token from the config\n- SaveToken() performs atomic updates to both in-memory config and persistent storage:\n  * Updates client's config reference and token field\n  * Calls new SaveConfig() function to marshal and write TOML file\n  * Gracefully handles file I/O errors with logging\n  * Validates parameters before processing\n- Added SaveConfig() function to config package for TOML serialization and file writing\n- All code compiles successfully and is ready for integration with OAuth2 TokenSource\n\nThe implementation provides thread-safe token updates and robust error handling for file operations, ensuring reliable token persistence across application restarts.\n</info added on 2025-06-29T20:09:11.552Z>",
            "status": "done",
            "testStrategy": "Mock file operations to test token save/load functionality with various token states"
          },
          {
            "id": 3,
            "title": "Integrate OAuth2 TokenSource for Automatic Refresh",
            "description": "Set up golang.org/x/oauth2 TokenSource to handle automatic token refresh",
            "dependencies": [
              2
            ],
            "details": "In NewClient, create a TokenSource using oauth2Config.TokenSource() with the loaded token. Wrap the http.Client with oauth2.NewClient() to enable automatic token refresh. The TokenSource will automatically refresh expired tokens using the refresh token when making API calls\n<info added on 2025-06-29T20:10:22.182Z>\nSuccessfully implemented OAuth2 TokenSource for automatic token refresh.\n\nImplementation details:\n- Modified NewClient() to create TokenSource using oauth2Config.TokenSource() with the loaded token\n- Wrapped HTTP client with oauth2.NewClient() to enable automatic token refresh\n- Added conditional logic to handle cases with/without tokens:\n  * With token: Creates OAuth-enabled HTTP client with TokenSource\n  * Without token: Creates basic HTTP client (API calls will fail until token set)\n- Updated SaveToken() method to recreate OAuth HTTP client when token is updated\n- Added GetHTTPClient() method to provide access to the configured HTTP client\n- Used oauth2.NoContext for OAuth operations as recommended for server applications\n\nThe TokenSource automatically handles token expiry and refresh using the refresh token when making API calls. The implementation ensures that both initial token setup and token updates maintain the OAuth transport functionality. Package builds successfully without errors.\n</info added on 2025-06-29T20:10:22.182Z>",
            "status": "done",
            "testStrategy": "Test with expired tokens to verify automatic refresh behavior, mock OAuth token endpoint responses"
          },
          {
            "id": 4,
            "title": "Implement Token Refresh Event Handling",
            "description": "Add callbacks and logging for token refresh events to track and persist new tokens",
            "dependencies": [
              3
            ],
            "details": "Create a custom RoundTripper that wraps the OAuth2 transport to intercept token refresh events. When a new token is obtained, call SaveToken() to persist it to the config file. Add structured logging using the project's logger to record refresh events, including timestamps and success/failure status\n<info added on 2025-06-29T20:12:26.206Z>\nSuccessfully implemented token refresh event handling with custom RoundTripper.\n\nImplementation details:\n- Created tokenRefreshTransport struct that implements http.RoundTripper interface\n- Added tokenSource field to Client struct for monitoring token changes\n- Modified NewClient() to wrap OAuth2 transport with custom transport for token refresh monitoring\n- Updated SaveToken() method to properly recreate custom transport when token is updated\n- Added saveTokenToFile() private method to persist tokens without recreating HTTP client (prevents recursion)\n- Implemented comprehensive logging for token refresh events:\n  * Logs when token refresh is detected\n  * Logs success/failure of token persistence\n  * Logs warnings for token access errors\n- The RoundTripper compares access tokens before/after each request to detect refreshes\n- When refresh detected, automatically persists new token to config file\n- Uses structured logging with [MIXCLOUD] prefix for easy identification\n\nThe implementation ensures that refreshed tokens are automatically persisted without manual intervention, providing seamless token management. All code builds successfully without errors.\n</info added on 2025-06-29T20:12:26.206Z>",
            "status": "done",
            "testStrategy": "Test RoundTripper with mock transport to verify token persistence after refresh"
          },
          {
            "id": 5,
            "title": "Add Error Handling and Graceful Degradation",
            "description": "Implement comprehensive error handling for OAuth failures and token refresh issues",
            "dependencies": [
              4
            ],
            "details": "Add error handling for: invalid refresh tokens (return specific error type), network failures during refresh (implement retry with backoff), config file write failures (log but continue with in-memory token). Create custom error types for different OAuth failure scenarios. Ensure the client can operate with degraded functionality if token refresh fails\n<info added on 2025-06-29T20:15:26.908Z>\nSuccessfully implemented comprehensive error handling and graceful degradation for OAuth failures and token refresh issues.\n\nImplementation details:\n- Created custom error types:\n  * OAuthError struct with Type, Message, Cause, and Retryable fields\n  * Pre-defined error variables for common scenarios (ErrInvalidRefreshToken, ErrNetworkFailure, etc.)\n  * Error wrapping and unwrapping support for better error context\n- Enhanced error handling throughout the codebase:\n  * Updated saveTokenToFile() and SaveToken() methods to use custom error types\n  * Added graceful degradation when HTTP client recreation fails\n  * Improved config file write failure handling (logs warning but continues)\n- Implemented retry logic with exponential backoff:\n  * executeWithRetry() method with 3 retry attempts and exponential backoff starting at 1 second\n  * Automatic retry for network failures and HTTP 429 (rate limited) responses\n  * shouldRetryError() function to classify transient vs permanent errors\n- Added error classification system:\n  * classifyError() method converts generic errors to specific OAuth errors\n  * Pattern matching for common OAuth error scenarios (invalid_grant, unauthorized, etc.)\n  * Network error detection for retry eligibility\n- Created health checking and status reporting:\n  * IsHealthy() method to check client operational status\n  * GetAuthenticationStatus() method providing detailed client state information\n  * Helps callers determine if client can make authenticated requests\n- Added graceful degradation features:\n  * Client continues with basic HTTP client when OAuth setup fails\n  * Comprehensive logging for all error scenarios and degraded states\n  * Retryable error classification to guide recovery strategies\n\nThe implementation ensures robust error handling while maintaining functionality even when some components fail. All code builds successfully without errors.\n</info added on 2025-06-29T20:15:26.908Z>",
            "status": "done",
            "testStrategy": "Test various failure scenarios: invalid refresh token, network errors, file system errors"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Show Name to URL Mapping",
        "description": "Create algorithm to convert show names to Mixcloud URL format following the platform's URL structure conventions",
        "details": "Add to mixcloud package:\n\n```go\nfunc GenerateShowURL(username, showName string) string {\n    // Example: \"Sounds Like - Jeri-Rig & V-Dub - 6/26/2025\"\n    // Result: \"sounds-like-jeri-rig-v-dub-6262025\"\n    \n    // Convert to lowercase\n    slug := strings.ToLower(showName)\n    \n    // Replace special characters with hyphens\n    replacer := strings.NewReplacer(\n        \" - \", \"-\",\n        \" & \", \"-\",\n        \" \", \"-\",\n        \"/\", \"\",\n        \".\", \"\",\n        \",\", \"\",\n        \"'\", \"\",\n        \"\\\"\", \"\",\n    )\n    slug = replacer.Replace(slug)\n    \n    // Remove duplicate hyphens\n    slug = regexp.MustCompile(`-+`).ReplaceAllString(slug, \"-\")\n    \n    // Trim hyphens from start/end\n    slug = strings.Trim(slug, \"-\")\n    \n    return fmt.Sprintf(\"https://www.mixcloud.com/%s/%s/\", username, slug)\n}\n```\n\nHandle edge cases:\n- Multiple consecutive spaces/hyphens\n- Special characters in DJ names\n- Various date formats (M/D/YYYY, MM/DD/YYYY)\n- Unicode characters in show names",
        "testStrategy": "Test with various show name formats from actual broadcasts, verify URLs match Mixcloud's actual URL structure, test edge cases with special characters and different date formats",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base URL Generation Function",
            "description": "Implement the core GenerateShowURL function with basic string transformations for converting show names to URL-safe slugs",
            "dependencies": [],
            "details": "Create the GenerateShowURL function in the mixcloud package that accepts username and showName parameters. Implement basic transformations: convert to lowercase, create a string replacer for common patterns (spaces to hyphens, removing slashes, dots, commas, quotes), and format the final URL with the Mixcloud domain pattern\n<info added on 2025-06-29T21:33:44.564Z>\nSuccessfully implemented the core GenerateShowURL function with basic string transformations.\n\nImplementation details:\n- Created GenerateShowURL function that accepts username and showName parameters\n- Added input validation to return empty string for empty parameters\n- Implemented basic transformations:\n  * Convert to lowercase for URL compatibility\n  * Use strings.NewReplacer for pattern replacement with proper ordering\n  * Replace \" - \" and \" & \" with single hyphens\n  * Remove special characters: /, ., , ', \"\n  * Replace remaining spaces with hyphens\n- Added regex-based duplicate hyphen removal using regexp.MustCompile(`-+`)\n- Implemented hyphen trimming from start and end using strings.Trim\n- Generate full Mixcloud URL with proper format: https://www.mixcloud.com/username/slug/\n- Added comprehensive comments explaining pattern replacement order and rationale\n\nThe function handles basic show name transformations and builds successfully. Ready for advanced character replacement logic in the next subtask.\n</info added on 2025-06-29T21:33:44.564Z>",
            "status": "done",
            "testStrategy": "Unit tests with basic show names like 'Test Show', 'Show - With - Hyphens', and 'Show 1/2/2025' to verify correct slug generation"
          },
          {
            "id": 2,
            "title": "Add Advanced Character Replacement Logic",
            "description": "Enhance the replacer to handle special characters in DJ names, ampersands, and other edge cases",
            "dependencies": [
              1
            ],
            "details": "Extend the strings.NewReplacer to handle more complex patterns: ' - ' to '-', ' & ' to '-', and any remaining spaces to hyphens. Ensure the order of replacements prevents edge cases where patterns might overlap. Add handling for parentheses, brackets, and other common punctuation marks used in show titles",
            "status": "done",
            "testStrategy": "Test with complex DJ names like 'DJ Name & Partner', 'Show (Live)', 'Artist [Special Guest]' to ensure all special characters are properly handled"
          },
          {
            "id": 3,
            "title": "Implement Hyphen Deduplication and Trimming",
            "description": "Add regex-based logic to remove duplicate hyphens and trim leading/trailing hyphens from the generated slug",
            "dependencies": [
              2
            ],
            "details": "Use regexp.MustCompile to create a pattern that matches multiple consecutive hyphens and replace them with a single hyphen. Apply strings.Trim to remove any hyphens from the start or end of the slug. Consider compiling the regex once as a package variable for performance",
            "status": "done",
            "testStrategy": "Test with edge cases like 'Show - - Name', '- Leading Hyphen', 'Trailing Hyphen -' to verify proper deduplication and trimming"
          },
          {
            "id": 4,
            "title": "Handle Date Format Variations",
            "description": "Add specialized handling for various date formats commonly used in show names to ensure consistent URL formatting",
            "dependencies": [
              3
            ],
            "details": "Before the main replacer, use regex patterns to detect and normalize date formats like M/D/YYYY, MM/DD/YYYY, M-D-YYYY, or written dates. Convert all date separators to a consistent format (removing slashes, dots, or hyphens between date components). Consider patterns like '(\\d{1,2})[/.-](\\d{1,2})[/.-](\\d{4})' for flexible date matching",
            "status": "done",
            "testStrategy": "Test with various date formats: '6/26/2025', '06/26/2025', '6-26-2025', '6.26.2025' to ensure consistent slug generation like '6262025'"
          },
          {
            "id": 5,
            "title": "Add Unicode Character Support",
            "description": "Implement handling for Unicode characters in show names, including accented characters and non-Latin scripts",
            "dependencies": [
              4
            ],
            "details": "Use golang.org/x/text/unicode/norm for Unicode normalization. Implement logic to either transliterate accented characters to their ASCII equivalents (é→e, ñ→n) or remove them entirely. Consider using the golang.org/x/text/transform package for more sophisticated character handling. Add a fallback for completely non-Latin text that might need special handling",
            "status": "done",
            "testStrategy": "Test with Unicode show names like 'Café Music Show', 'Señor DJ', '音楽 Show', and mixed scripts to ensure proper handling or graceful degradation"
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Mixcloud API Integration",
        "description": "Implement API client methods to fetch show information and update descriptions using Mixcloud's REST API",
        "details": "Extend mixcloud Client with API methods:\n\n```go\nfunc (c *Client) GetShow(showURL string) (*Show, error) {\n    // Extract cloudcast key from URL\n    // Make GET request to /cloudcast/<key>/\n    // Parse JSON response\n    // Return Show struct with current description\n}\n\nfunc (c *Client) UpdateShowDescription(showURL, description string) error {\n    // Extract cloudcast key from URL\n    // Prepare multipart form data\n    // Make POST request to /upload/\n    // Handle rate limiting (429 status)\n    // Verify update was successful\n}\n\ntype Show struct {\n    Key         string `json:\"key\"`\n    Name        string `json:\"name\"`\n    Description string `json:\"description\"`\n    URL         string `json:\"url\"`\n}\n```\n\nImplement error handling:\n- Network timeouts (30 second timeout)\n- Rate limiting with exponential backoff\n- Invalid show URLs\n- API authentication failures\n- Validation of description length (1000 char limit)",
        "testStrategy": "Mock Mixcloud API responses for testing, verify correct API endpoints are called, test rate limit handling with retry logic, validate description updates with various content lengths",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Mixcloud API data structures and client configuration",
            "description": "Create the foundational data structures for the Mixcloud API integration including the Show struct, error types, and client configuration with authentication and timeout settings",
            "dependencies": [],
            "details": "Define the Show struct with JSON tags for API response parsing. Create custom error types for rate limiting, invalid URLs, and API failures. Set up the Client struct with HTTP client configuration including 30-second timeout, authentication headers, and base URL. Define constants for API endpoints (/cloudcast/, /upload/) and rate limit retry parameters.",
            "status": "done",
            "testStrategy": "Unit tests to verify struct marshaling/unmarshaling, error type implementations, and client initialization with proper configuration"
          },
          {
            "id": 2,
            "title": "Implement URL parsing and cloudcast key extraction",
            "description": "Create utility functions to parse Mixcloud show URLs and extract the cloudcast key needed for API requests",
            "dependencies": [],
            "details": "Implement a function to parse URLs like 'https://www.mixcloud.com/username/show-name/' and extract the cloudcast key format 'username/show-name/'. Handle various URL formats including with/without www, http/https, and trailing slashes. Validate the URL structure and return appropriate errors for invalid formats.",
            "status": "done",
            "testStrategy": "Table-driven tests with various valid and invalid URL formats to ensure correct key extraction and error handling"
          },
          {
            "id": 3,
            "title": "Implement GetShow method with API response handling",
            "description": "Create the GetShow method to fetch show information from the Mixcloud API and parse the JSON response into the Show struct",
            "dependencies": [
              1,
              2
            ],
            "details": "Use the URL parser to extract the cloudcast key, construct the API endpoint URL, make a GET request with proper authentication headers, handle various HTTP status codes (200, 404, 401, 500), parse the JSON response into the Show struct, and implement proper error wrapping for debugging. Handle network timeouts and connection errors gracefully.",
            "status": "done",
            "testStrategy": "Integration tests with mock HTTP server to test various response scenarios, unit tests for JSON parsing logic"
          },
          {
            "id": 4,
            "title": "Implement UpdateShowDescription with multipart form handling",
            "description": "Create the UpdateShowDescription method to update show descriptions via the Mixcloud upload API endpoint with proper form data encoding",
            "dependencies": [
              1,
              2
            ],
            "details": "Extract cloudcast key from URL, validate description length (1000 char limit), create multipart form data with the cloudcast key and new description fields, make POST request to /upload/ endpoint with proper content-type header, handle successful responses and API-specific error codes. Implement request retry logic for transient failures.",
            "status": "done",
            "testStrategy": "Integration tests with mock server for multipart form validation, unit tests for description validation and form data construction"
          },
          {
            "id": 5,
            "title": "Implement rate limiting with exponential backoff",
            "description": "Add rate limiting detection and retry logic with exponential backoff to both API methods to handle 429 responses gracefully",
            "dependencies": [
              3,
              4
            ],
            "details": "Detect 429 status codes and Retry-After headers, implement exponential backoff starting at 1 second with a maximum of 5 retries, respect Retry-After header if provided, add jitter to prevent thundering herd, log retry attempts for debugging, return appropriate errors after max retries exceeded. Ensure both GetShow and UpdateShowDescription methods use this retry logic.",
            "status": "done",
            "testStrategy": "Unit tests with mock time and HTTP responses to verify backoff calculations and retry behavior, integration tests to ensure methods handle rate limiting correctly"
          }
        ]
      },
      {
        "id": 8,
        "title": "Create Tracklist Formatter",
        "description": "Build formatter to convert filtered CUE tracks into properly formatted tracklist for Mixcloud description",
        "details": "Implement formatter in internal/formatter/:\n\n```go\ntype Formatter struct {\n    maxLength int  // Mixcloud's 1000 character limit\n}\n\nfunc (f *Formatter) FormatTracklist(tracks []cue.Track, filter *filter.Filter) string {\n    var lines []string\n    \n    for _, track := range tracks {\n        if !filter.ShouldIncludeTrack(&track) {\n            continue\n        }\n        \n        // Format: MM:SS - \"Track Title\" by Artist Name\n        line := fmt.Sprintf(`%s - \"%s\" by %s`,\n            track.StartTime,\n            track.Title,\n            track.Artist)\n        \n        lines = append(lines, line)\n    }\n    \n    // Join with newlines\n    tracklist := strings.Join(lines, \"\\n\")\n    \n    // Truncate if exceeds character limit\n    if len(tracklist) > f.maxLength {\n        tracklist = f.truncateSmartly(tracklist)\n    }\n    \n    return tracklist\n}\n```\n\nImplement smart truncation:\n- Cut at line boundaries, not mid-line\n- Add \"... and more\" if truncated\n- Prioritize keeping earlier tracks\n- Preserve formatting integrity",
        "testStrategy": "Test formatting with various track counts, verify output stays within 1000 character limit, test truncation logic preserves complete track entries, validate special characters in titles are properly escaped",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define formatter package structure and interfaces",
            "description": "Create the base package structure for the formatter module with proper interfaces and type definitions",
            "dependencies": [],
            "details": "Create internal/formatter/formatter.go with Formatter struct definition including maxLength field set to 1000 for Mixcloud's limit. Define FormatterInterface with FormatTracklist method signature. Create package documentation explaining the formatter's purpose and usage.",
            "status": "done",
            "testStrategy": "Create formatter_test.go with basic instantiation tests to verify struct creation and default values"
          },
          {
            "id": 2,
            "title": "Implement track filtering logic in FormatTracklist",
            "description": "Build the core logic to iterate through tracks and apply filter conditions to select which tracks to include",
            "dependencies": [
              1
            ],
            "details": "Implement the FormatTracklist method that accepts []cue.Track and *filter.Filter parameters. Loop through tracks array and use filter.ShouldIncludeTrack() to determine inclusion. Store filtered tracks in a temporary slice for formatting.",
            "status": "done",
            "testStrategy": "Test with mock filter that includes/excludes specific tracks based on criteria. Verify only filtered tracks are processed."
          },
          {
            "id": 3,
            "title": "Implement track line formatting",
            "description": "Create the formatting logic to convert each track into the specified string format",
            "dependencies": [
              2
            ],
            "details": "For each filtered track, format as 'MM:SS - \"Track Title\" by Artist Name' using fmt.Sprintf. Handle edge cases like missing artist names or special characters in titles. Ensure proper quote escaping for track titles. Build lines slice with formatted strings.",
            "status": "done",
            "testStrategy": "Test various track inputs including edge cases: empty titles, missing artists, special characters, long names"
          },
          {
            "id": 4,
            "title": "Implement smart truncation logic",
            "description": "Build the truncateSmartly method to handle character limit enforcement while preserving formatting",
            "dependencies": [
              3
            ],
            "details": "Create truncateSmartly(tracklist string) string method that: splits tracklist by newlines, iteratively adds lines while tracking total length, stops before exceeding maxLength, ensures last line is complete (no partial lines), appends '... and more' if truncated. Handle edge case where even first track exceeds limit.",
            "status": "done",
            "testStrategy": "Test with tracklists of various lengths: under limit, exactly at limit, slightly over, significantly over. Verify truncation preserves complete lines and adds ellipsis appropriately."
          },
          {
            "id": 5,
            "title": "Integration testing and edge case handling",
            "description": "Create comprehensive integration tests and handle remaining edge cases",
            "dependencies": [
              4
            ],
            "details": "Write integration tests combining all components: various track counts, different filter configurations, boundary testing for character limits. Add error handling for nil inputs. Optimize performance for large track lists. Add logging for debugging truncation decisions.",
            "status": "done",
            "testStrategy": "Create test cases with real-world scenarios: 50+ track mixes, various artist/title lengths, different filter combinations. Benchmark performance with large datasets."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Command-Line Interface",
        "description": "Create CLI with argument parsing for cue file path, config file, show name, and other runtime options",
        "details": "Implement in cmd/mixcloud-updater/main.go:\n\n```go\nfunc main() {\n    var (\n        cueFile  = flag.String(\"cue-file\", \"\", \"Path to CUE file\")\n        configFile = flag.String(\"config\", \"config.toml\", \"Path to config file\")\n        showName = flag.String(\"show-name\", \"\", \"Show name for URL matching\")\n        dryRun   = flag.Bool(\"dry-run\", false, \"Preview without updating\")\n    )\n    flag.Parse()\n    \n    // Validate required arguments\n    if *cueFile == \"\" {\n        log.Fatal(\"--cue-file is required\")\n    }\n    \n    // Load configuration\n    cfg, err := config.LoadConfig(*configFile)\n    if err != nil {\n        log.Fatalf(\"Failed to load config: %v\", err)\n    }\n    \n    // Initialize components\n    // Parse CUE file\n    // Filter tracks\n    // Format tracklist\n    // Update Mixcloud\n    // Log results\n}\n```\n\nImplement validation:\n- Check cue file exists and is readable\n- Validate config file format\n- Handle platform-specific path formats\n- Provide helpful error messages",
        "testStrategy": "Test CLI with various argument combinations, verify error messages for missing/invalid arguments, test path handling on both Windows and MacOS, ensure --dry-run prevents API calls",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define CLI structure and argument parsing",
            "description": "Set up the command-line interface structure with proper argument definitions using Go's flag package",
            "dependencies": [],
            "details": "Create main.go in cmd/mixcloud-updater/ directory. Define all command-line flags including cue-file (required), config (default: config.toml), show-name (optional), and dry-run (boolean). Set up flag parsing and basic usage/help text formatting. Include version flag for binary versioning.",
            "status": "done",
            "testStrategy": "Write unit tests to verify flag parsing logic handles various input combinations correctly"
          },
          {
            "id": 2,
            "title": "Implement argument validation and file checks",
            "description": "Add comprehensive validation for all command-line arguments and verify file accessibility",
            "dependencies": [
              1
            ],
            "details": "After flag.Parse(), validate that cue-file is provided and points to an existing, readable file. Check config file exists (use default if not provided). Handle platform-specific path formats (Windows vs Unix). Validate show-name format if provided. Return clear, actionable error messages for each validation failure.",
            "status": "done",
            "testStrategy": "Test with missing files, invalid paths, different OS path formats, and permission issues"
          },
          {
            "id": 3,
            "title": "Create configuration loading integration",
            "description": "Integrate the config package to load and validate configuration from the specified file",
            "dependencies": [
              2
            ],
            "details": "Call config.LoadConfig() with the validated config file path. Handle potential errors during config loading (file not found, invalid TOML format, missing required fields). Pass loaded configuration to subsequent components. Ensure config validation errors are clearly reported to the user.",
            "status": "done",
            "testStrategy": "Test with valid configs, malformed TOML, missing required fields, and empty config files"
          },
          {
            "id": 4,
            "title": "Wire up component initialization and orchestration",
            "description": "Initialize all application components and orchestrate the main workflow",
            "dependencies": [
              3
            ],
            "details": "Create instances of CUE parser, track filter, formatter, and Mixcloud client using loaded config. Implement the main workflow: parse CUE file, filter tracks based on config, format tracklist, and update Mixcloud (respecting dry-run flag). Pass show-name to components that need it for URL matching. Handle errors at each step with appropriate logging.",
            "status": "done",
            "testStrategy": "Integration tests covering the full workflow with mock components, testing both success and failure scenarios"
          },
          {
            "id": 5,
            "title": "Implement logging and result reporting",
            "description": "Add comprehensive logging throughout the CLI execution and final result reporting",
            "dependencies": [
              4
            ],
            "details": "Set up structured logging (consider using log/slog or similar). Log key events: config loaded, CUE file parsed (track count), tracks filtered (before/after counts), dry-run mode status, Mixcloud update attempts and results. Provide a summary at the end showing what was updated or what would be updated in dry-run mode. Include timing information for performance monitoring.",
            "status": "done",
            "testStrategy": "Verify log output format and content for various scenarios, ensure dry-run mode clearly indicates no actual updates"
          }
        ]
      },
      {
        "id": 10,
        "title": "Integrate Components and Add Logging",
        "description": "Wire together all components in main application flow and implement comprehensive console logging for monitoring",
        "status": "done",
        "dependencies": [
          3,
          4,
          7,
          8,
          9
        ],
        "priority": "high",
        "details": "This task has been completed as part of Task 9's comprehensive CLI implementation. The main.go file includes all the requested integration and logging functionality, plus additional production-ready features:\n\n**Completed Features:**\n- ✅ Full component integration in main application flow\n- ✅ Comprehensive console logging with timestamps and context\n- ✅ Professional CLI help system with usage examples\n- ✅ Platform-specific path handling and validation\n- ✅ Rich progress reporting with step-by-step timing\n- ✅ Detailed workflow summary with statistics and metrics\n- ✅ Advanced error handling with wrapped errors\n- ✅ Dry-run mode with formatted preview output\n- ✅ Configuration management with environment overrides\n\n**Key Implementation Details:**\n- Start/end logging for each major operation\n- Track counts (found/filtered) with detailed statistics\n- API request/response logging with timing metrics\n- Error context with properly wrapped errors using fmt.Errorf\n- Success confirmation with comprehensive summary\n- Performance metrics (parse time, format time, API time)\n\nThe implementation exceeds the original requirements by providing a production-ready CLI interface with professional error handling, detailed progress reporting, and comprehensive logging suitable for both development and production environments.",
        "testStrategy": "Verify through existing implementation: run end-to-end tests with sample CUE files, confirm complete workflow from parsing to API update works correctly, validate error scenarios produce appropriate log messages, ensure logging output provides sufficient debugging information with timing and statistics",
        "subtasks": [
          {
            "id": 1,
            "title": "Create main.go with base structure and imports",
            "description": "Set up the main.go file with proper package declaration, imports, and basic command structure including flag parsing for cue-file, show-name, and dry-run options",
            "status": "done",
            "dependencies": [],
            "details": "Create cmd/nwrmixcloud/main.go with imports for flag, log, fmt, os, and internal packages. Set up main() function with flag definitions for -cue-file (string), -show (string), and -dry-run (bool). Add basic validation for required flags and call to processShow function",
            "testStrategy": "Manual testing with various flag combinations to ensure proper parsing and validation"
          },
          {
            "id": 2,
            "title": "Implement processShow function with CUE parsing and logging",
            "description": "Create the processShow function that handles CUE file parsing with detailed logging of the parsing process and results",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement processShow function signature with (cfg *config.Config, cueFile, showName string, dryRun bool) error. Add Step 1 implementation: log CUE file path being parsed, call cue.ParseCueFile, handle errors with wrapped context, log number of tracks found. Ensure proper error formatting with fmt.Errorf",
            "testStrategy": "Test with valid and invalid CUE files, verify log output shows file path and track count"
          },
          {
            "id": 3,
            "title": "Add filter initialization and tracklist formatting with logging",
            "description": "Implement filter creation and tracklist formatting steps with comprehensive logging of the filtering and formatting process",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Add Step 2: Initialize filter with error handling and logging. Add Step 3: Create formatter instance with MaxLength: 1000, call FormatTracklist with tracks and filter, log the generated tracklist length. Implement dry-run check that logs 'DRY RUN - Would update with:' followed by the tracklist content",
            "testStrategy": "Test with various track configurations, verify character count logging and dry-run output"
          },
          {
            "id": 4,
            "title": "Implement Mixcloud API integration with request/response logging",
            "description": "Add the Mixcloud client creation and API update functionality with detailed logging of API interactions",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Add Step 4: Create Mixcloud client with error handling, generate show URL using mixcloud.GenerateShowURL, log the full URL being updated. Call UpdateShowDescription with proper error handling. Add success confirmation log. Ensure all errors are wrapped with context using fmt.Errorf",
            "testStrategy": "Test with mock API client to verify logging of requests and responses, test error scenarios"
          },
          {
            "id": 5,
            "title": "Add configuration loading and comprehensive error handling",
            "description": "Implement configuration loading in main function and ensure all error paths have proper logging and context",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "In main(), add config loading before calling processShow. Add start/end operation logging with timestamps. Ensure all error returns include context about what operation failed. Add defer function to log completion status. Set up log format with timestamps using log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)",
            "testStrategy": "Test with missing config, invalid inputs, and API failures to verify all error paths produce clear, contextual log messages"
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Templating System for Customizable Tracklist Output",
        "description": "Create a flexible templating system using Go's text/template package that allows users to define custom tracklist output formats in the config file, supporting headers, footers, and multiple named templates for different use cases",
        "details": "Extend the formatter package to support Go's text/template syntax:\n\n```go\ntype TemplateFormatter struct {\n    templates map[string]*template.Template\n    fallback  *Formatter // existing formatter for backward compatibility\n}\n\ntype TemplateData struct {\n    ShowTitle    string\n    ShowDate     string\n    TrackCount   int\n    Tracks       []FormattedTrack\n    StationName  string\n    Custom       map[string]interface{} // user-defined variables\n}\n\ntype FormattedTrack struct {\n    Index     int\n    StartTime string\n    Artist    string\n    Title     string\n    Genre     string\n    Duration  string // if available\n}\n```\n\nAdd template configuration to config.toml:\n```toml\n[templates]\ndefault = \"classic\" # fallback to hardcoded format\n\n[templates.minimal]\nheader = \"Tracklist:\\n\"\ntrack = \"{{.StartTime}} - {{.Title}} by {{.Artist}}\\n\"\nfooter = \"\\nTotal tracks: {{.TrackCount}}\"\n\n[templates.detailed]\nheader = \"{{.ShowTitle}} - {{.ShowDate}}\\n{{repeat \"-\" 50}}\\n\"\ntrack = \"{{printf \"%02d\" .Index}}. [{{.StartTime}}] {{.Artist}} - {{.Title}}{{if .Genre}} ({{.Genre}}){{end}}\\n\"\nfooter = \"\\n{{repeat \"-\" 50}}\\nBroadcast by {{.StationName}} | {{.TrackCount}} tracks played\"\n\n[templates.markdown]\nheader = \"## {{.ShowTitle}}\\n### {{.ShowDate}}\\n\\n\"\ntrack = \"- **{{.StartTime}}** - *{{.Title}}* by {{.Artist}}\\n\"\nfooter = \"\\n---\\n*Generated automatically from CUE sheet*\"\n```\n\nImplement template functions:\n```go\nfunc (tf *TemplateFormatter) LoadTemplates(config *config.Config) error {\n    // Parse template definitions from config\n    // Register custom template functions:\n    funcMap := template.FuncMap{\n        \"repeat\": strings.Repeat,\n        \"upper\":  strings.ToUpper,\n        \"lower\":  strings.ToLower,\n        \"truncate\": func(s string, n int) string {\n            if len(s) <= n {\n                return s\n            }\n            return s[:n] + \"...\"\n        },\n    }\n}\n\nfunc (tf *TemplateFormatter) FormatWithTemplate(name string, tracks []cue.Track, filter *filter.Filter, metadata map[string]interface{}) (string, error) {\n    // Select template by name\n    // Build TemplateData struct\n    // Execute header, tracks, footer templates\n    // Respect 1000 character limit with smart truncation\n}\n```\n\nUpdate CLI to support template selection:\n```go\ntemplateName := flag.String(\"template\", \"default\", \"Template name to use for formatting\")\n```\n\nEnsure backward compatibility:\n- If no templates defined in config, use existing hardcoded format\n- If template parsing fails, fall back to classic formatter\n- Maintain the same FormatTracklist() interface for existing code",
        "testStrategy": "Create comprehensive test suite for template functionality:\n1. Test template parsing from various config formats\n2. Verify all built-in template functions work correctly (repeat, truncate, etc.)\n3. Test with missing template sections (header/footer optional)\n4. Validate character limit enforcement with templates\n5. Test backward compatibility when no templates defined\n6. Create edge case templates with complex conditionals and loops\n7. Verify template errors are handled gracefully with fallback\n8. Test custom template variables passed through metadata\n9. Validate template output matches expected format for each preset\n10. Performance test template rendering with large track lists",
        "status": "pending",
        "dependencies": [
          2,
          8
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Template Configuration Schema to Config System",
            "description": "Extend the existing config package to support template definitions in config.toml, including parsing template sections with header, track, and footer fields",
            "dependencies": [],
            "details": "Update internal/config/config.go to add TemplateConfig struct and Templates map[string]TemplateConfig. Add fields for header, track, footer strings and default template name. Implement TOML unmarshaling for the new [templates] section structure",
            "status": "pending",
            "testStrategy": "Create unit tests with sample TOML configurations containing various template definitions. Test parsing of nested template sections, missing fields, and invalid configurations"
          },
          {
            "id": 2,
            "title": "Create Template Engine Module with Core Functionality",
            "description": "Implement a new template engine that uses Go's text/template package to process tracklist formatting with custom functions and data structures",
            "dependencies": [
              1
            ],
            "details": "Create internal/template/engine.go with TemplateFormatter struct containing templates map and fallback formatter. Implement LoadTemplates() to parse template strings from config and register custom functions (repeat, upper, lower, truncate). Define TemplateData and FormattedTrack structs for template execution",
            "status": "pending",
            "testStrategy": "Unit test template parsing, function registration, and execution with mock data. Test custom template functions independently and verify error handling for malformed templates"
          },
          {
            "id": 3,
            "title": "Implement Template-Based Formatting with Smart Truncation",
            "description": "Create FormatWithTemplate method that executes templates with track data while respecting Mixcloud's 1000 character limit",
            "dependencies": [
              2
            ],
            "details": "Implement FormatWithTemplate() method that builds TemplateData from tracks and metadata, executes header/track/footer templates separately, and applies smart truncation at line boundaries when approaching character limit. Handle template execution errors gracefully",
            "status": "pending",
            "testStrategy": "Test formatting with various track counts and template styles. Verify character limit enforcement, smart truncation behavior, and proper handling of missing template fields"
          },
          {
            "id": 4,
            "title": "Integrate Template Engine with Existing Formatter Package",
            "description": "Modify the formatter package to support both legacy hardcoded format and new template-based formatting with seamless fallback",
            "dependencies": [
              3
            ],
            "details": "Update internal/formatter/formatter.go to detect template configuration and delegate to TemplateFormatter when templates are defined. Maintain FormatTracklist() interface for backward compatibility. Implement fallback logic when template parsing fails or no templates configured",
            "status": "pending",
            "testStrategy": "Integration tests verifying both legacy and template-based formatting work correctly. Test fallback scenarios when templates are unavailable or malformed"
          },
          {
            "id": 5,
            "title": "Add CLI Flag for Template Selection",
            "description": "Extend the command-line interface to accept a template name parameter for selecting which template to use during formatting",
            "dependencies": [
              4
            ],
            "details": "Update cmd/mixcloud-updater/main.go to add -template flag with default value 'default'. Pass template name through to formatter. Update help text to describe template usage. Handle invalid template names gracefully with informative error messages",
            "status": "pending",
            "testStrategy": "Test CLI with various template names including default, custom, and invalid names. Verify proper error messages and fallback behavior"
          },
          {
            "id": 6,
            "title": "Implement Template Validation and Error Handling",
            "description": "Add comprehensive validation for template definitions to catch errors early and provide helpful feedback to users",
            "dependencies": [
              2
            ],
            "details": "Create ValidateTemplate() method to check template syntax during loading. Validate required template variables are available in TemplateData. Implement detailed error messages indicating which template and line has issues. Add template listing functionality to show available templates",
            "status": "pending",
            "testStrategy": "Test validation with malformed templates, missing variables, and syntax errors. Verify error messages are clear and actionable"
          },
          {
            "id": 7,
            "title": "Add Comprehensive Tests and Update Documentation",
            "description": "Create thorough test coverage for the templating system and update all relevant documentation including README and CLAUDE.md",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Write table-driven tests for each template component. Add example templates to config.toml.example. Update README with template usage examples and available functions. Document template data structure in CLAUDE.md. Create integration tests with real CUE files using different templates",
            "status": "pending",
            "testStrategy": "Ensure 80%+ test coverage for new template code. Test edge cases like empty tracks, very long outputs, and Unicode handling. Verify documentation examples work as shown"
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement unified config-driven architecture for single-command operation",
        "description": "Transform the application into a single-command tool that processes all configured shows based on a comprehensive config file, incorporating smart show detection, templating, and automatic multi-show processing",
        "details": "Restructure the application to support a unified config-driven workflow:\n\n```go\n// Enhanced config structure in internal/config/config.go\ntype Config struct {\n    // Existing sections remain...\n    \n    Shows map[string]ShowConfig `toml:\"shows\"`\n    \n    Processing struct {\n        CueFileDirectory string `toml:\"cue_file_directory\"`\n        AutoProcess      bool   `toml:\"auto_process\"`\n        BatchSize        int    `toml:\"batch_size\"`\n    } `toml:\"processing\"`\n}\n\ntype ShowConfig struct {\n    // CUE file mapping\n    CueFilePattern   string `toml:\"cue_file_pattern\"` // e.g., \"MYR*.cue\"\n    CueFileMapping   string `toml:\"cue_file_mapping\"` // e.g., \"latest.cue\" or specific file\n    \n    // Show identification\n    ShowNamePattern  string `toml:\"show_name_pattern\"` // e.g., \"Sounds Like - {date}\"\n    Aliases          []string `toml:\"aliases\"` // e.g., [\"sounds-like\", \"sl\"]\n    \n    // Template overrides\n    TemplateName     string `toml:\"template\"` // Reference to templates section\n    CustomTemplate   string `toml:\"custom_template\"` // Inline template override\n    \n    // Date/time handling\n    DateExtraction   string `toml:\"date_extraction\"` // Regex to extract date from filename\n    DateFormat       string `toml:\"date_format\"` // Format for show title generation\n    \n    // Processing options\n    Enabled          bool   `toml:\"enabled\"`\n    Priority         int    `toml:\"priority\"`\n}\n```\n\nImplement new command structure in cmd/mixcloud-updater/main.go:\n\n```go\nfunc main() {\n    // Simplified CLI - config file is the only required argument\n    configFile := flag.String(\"config\", \"config.toml\", \"Configuration file\")\n    showAlias := flag.String(\"show\", \"\", \"Process specific show by name/alias\")\n    dryRun := flag.Bool(\"dry-run\", false, \"Preview without updating\")\n    flag.Parse()\n    \n    // Support single argument mode: ./mixcloud-updater config.toml\n    if flag.NArg() == 1 && *configFile == \"config.toml\" {\n        *configFile = flag.Arg(0)\n    }\n    \n    cfg, err := config.Load(*configFile)\n    if err != nil {\n        log.Fatalf(\"Failed to load config: %v\", err)\n    }\n    \n    processor := NewShowProcessor(cfg)\n    \n    if *showAlias != \"\" {\n        // Process single show by alias\n        if err := processor.ProcessShow(*showAlias, *dryRun); err != nil {\n            log.Fatalf(\"Failed to process show: %v\", err)\n        }\n    } else {\n        // Process all enabled shows\n        if err := processor.ProcessAllShows(*dryRun); err != nil {\n            log.Fatalf(\"Failed to process shows: %v\", err)\n        }\n    }\n}\n```\n\nCreate ShowProcessor to handle the new workflow:\n\n```go\ntype ShowProcessor struct {\n    config      *config.Config\n    mixcloud    *mixcloud.Client\n    formatter   *formatter.TemplateFormatter\n    filter      *filter.Filter\n}\n\nfunc (p *ShowProcessor) ProcessShow(nameOrAlias string, dryRun bool) error {\n    // Find show config by name or alias\n    showCfg := p.findShowConfig(nameOrAlias)\n    if showCfg == nil {\n        return fmt.Errorf(\"show not found: %s\", nameOrAlias)\n    }\n    \n    // Determine CUE file to process\n    cueFile, err := p.resolveCueFile(showCfg)\n    if err != nil {\n        return fmt.Errorf(\"resolving CUE file: %w\", err)\n    }\n    \n    // Parse CUE file\n    cueSheet, err := cue.ParseCueFile(cueFile)\n    if err != nil {\n        return fmt.Errorf(\"parsing CUE file: %w\", err)\n    }\n    \n    // Generate show name with date substitution\n    showName := p.generateShowName(showCfg, cueFile)\n    \n    // Format tracklist using show-specific template\n    template := p.selectTemplate(showCfg)\n    tracklist := p.formatter.Format(cueSheet.Tracks, template, showName)\n    \n    if dryRun {\n        fmt.Printf(\"Would update: %s\\n%s\\n\", showName, tracklist)\n        return nil\n    }\n    \n    // Update Mixcloud\n    return p.mixcloud.UpdateShowDescription(showName, tracklist)\n}\n\nfunc (p *ShowProcessor) resolveCueFile(cfg *ShowConfig) (string, error) {\n    if cfg.CueFileMapping != \"\" {\n        // Direct file mapping\n        path := filepath.Join(p.config.Processing.CueFileDirectory, cfg.CueFileMapping)\n        if _, err := os.Stat(path); err != nil {\n            return \"\", err\n        }\n        return path, nil\n    }\n    \n    if cfg.CueFilePattern != \"\" {\n        // Pattern-based matching (find latest)\n        pattern := filepath.Join(p.config.Processing.CueFileDirectory, cfg.CueFilePattern)\n        matches, err := filepath.Glob(pattern)\n        if err != nil {\n            return \"\", err\n        }\n        if len(matches) == 0 {\n            return \"\", fmt.Errorf(\"no files match pattern: %s\", pattern)\n        }\n        // Return most recent file\n        return findLatestFile(matches), nil\n    }\n    \n    return \"\", fmt.Errorf(\"no CUE file mapping configured\")\n}\n\nfunc (p *ShowProcessor) generateShowName(cfg *ShowConfig, cueFile string) string {\n    showName := cfg.ShowNamePattern\n    \n    // Extract date from filename if configured\n    if cfg.DateExtraction != \"\" {\n        re := regexp.MustCompile(cfg.DateExtraction)\n        if matches := re.FindStringSubmatch(filepath.Base(cueFile)); len(matches) > 1 {\n            date := matches[1]\n            // Format date if needed\n            if cfg.DateFormat != \"\" {\n                date = formatDate(date, cfg.DateFormat)\n            }\n            showName = strings.Replace(showName, \"{date}\", date, -1)\n        }\n    }\n    \n    // Replace other placeholders\n    showName = strings.Replace(showName, \"{station}\", p.config.Station.Name, -1)\n    \n    return showName\n}\n```\n\nExample comprehensive config.toml:\n\n```toml\n[station]\nname = \"Example FM\"\nmixcloud_username = \"examplefm\"\n\n[oauth]\nclient_id = \"...\"\nclient_secret = \"...\"\n# Tokens auto-managed\n\n[processing]\ncue_file_directory = \"/radio/playout/logs\"\nauto_process = true\nbatch_size = 5\n\n# Template definitions\n[templates.default]\nheader = \"Today's tracklist:\"\ntrack_format = \"{{.Time}} - {{.Title}} by {{.Artist}}\"\nfooter = \"Thanks for listening!\"\n\n[templates.detailed]\nheader = \"=== {{.ShowTitle}} ===\\nAired: {{.ShowDate}}\\n\\nTracklist:\"\ntrack_format = \"[{{.Index}}] {{.Time}} - \\\"{{.Title}}\\\" by {{.Artist}}\"\nfooter = \"\\nTotal tracks: {{.TrackCount}}\"\n\n# Show configurations\n[shows.newer-new-wave]\ncue_file_pattern = \"MYR4*.cue\"\nshow_name_pattern = \"The Newer New Wave Show - {date}\"\naliases = [\"nnw\", \"new-wave\"]\ntemplate = \"default\"\ndate_extraction = \"MYR4(\\\\d{4})\"\ndate_format = \"01/02/2006\"\nenabled = true\npriority = 1\n\n[shows.sounds-like]\ncue_file_mapping = \"latest-sounds-like.cue\"\nshow_name_pattern = \"Sounds Like - Jeri-Rig & V-Dub - {date}\"\naliases = [\"sl\", \"sounds\"]\ntemplate = \"detailed\"\ndate_extraction = \"(\\\\d{2}-\\\\d{2}-\\\\d{4})\"\nenabled = true\npriority = 2\n\n[shows.morning-show]\ncue_file_pattern = \"morning-*.cue\"\nshow_name_pattern = \"Morning Drive - {date}\"\naliases = [\"morning\", \"am\"]\n# Inline custom template\ncustom_template = \"\"\"Morning Show Playlist:\n{{range .Tracks}}{{.Time}} {{.Title}}{{end}}\"\"\"\nenabled = true\n```\n\nUsage examples:\n```bash\n# Process all enabled shows\n./mixcloud-updater config.toml\n\n# Process specific show by alias\n./mixcloud-updater config.toml -show nnw\n./mixcloud-updater config.toml -show sounds-like\n\n# Dry run to preview\n./mixcloud-updater config.toml -dry-run\n\n# Using show alias shortcuts\n./mixcloud-updater config.toml -show morning\n```",
        "testStrategy": "Comprehensive testing strategy for unified config architecture:\n\n1. **Config Loading Tests:**\n   - Test loading complex config with multiple shows\n   - Verify show alias resolution works correctly\n   - Test template inheritance and overrides\n   - Validate config with missing sections\n\n2. **CUE File Resolution Tests:**\n   - Test pattern matching with glob patterns\n   - Verify direct file mapping works\n   - Test latest file selection from multiple matches\n   - Validate error handling for missing files\n\n3. **Show Name Generation Tests:**\n   - Test date extraction from various filename formats\n   - Verify date formatting with different patterns\n   - Test placeholder substitution ({date}, {station})\n   - Validate show name generation without date\n\n4. **Multi-Show Processing Tests:**\n   - Test processing all enabled shows in priority order\n   - Verify disabled shows are skipped\n   - Test batch processing with size limits\n   - Validate error handling continues to next show\n\n5. **Template Selection Tests:**\n   - Test show-specific template selection\n   - Verify inline custom templates work\n   - Test fallback to default template\n   - Validate template data population\n\n6. **CLI Behavior Tests:**\n   - Test single argument mode (./mixcloud-updater config.toml)\n   - Verify show alias resolution in CLI\n   - Test dry-run mode prevents API calls\n   - Validate error messages for invalid shows\n\n7. **Integration Tests:**\n   - Create test config with 3+ show definitions\n   - Place test CUE files matching patterns\n   - Run full workflow and verify correct processing\n   - Test with real Mixcloud API in dry-run mode",
        "status": "pending",
        "dependencies": [
          2,
          5,
          6,
          7,
          8,
          9,
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend config schema to support shows, templates, and processing options",
            "description": "Update the config structure to include new sections for show configurations, template definitions, and processing settings while maintaining backward compatibility",
            "dependencies": [],
            "details": "Modify internal/config/config.go to add ShowConfig struct with fields for cue_file_pattern, cue_file_mapping, show_name_pattern, aliases, template references, date handling, and processing options. Add Processing struct for batch settings and cue_file_directory. Add Templates map[string]TemplateConfig for template definitions. Update Load() function to properly unmarshal these new sections from TOML. Ensure existing config fields remain functional.",
            "status": "pending",
            "testStrategy": "Create unit tests with sample TOML configs testing various show configurations, template definitions, and processing options. Test backward compatibility with existing configs."
          },
          {
            "id": 2,
            "title": "Implement show alias resolution and lookup system",
            "description": "Create a system to resolve show names and aliases to their corresponding configurations, supporting both primary names and multiple aliases per show",
            "dependencies": [
              1
            ],
            "details": "Create internal/shows/resolver.go with ShowResolver struct containing methods like FindShowConfig(nameOrAlias string) *config.ShowConfig. Build alias map during initialization by iterating through all show configs and indexing by both show key and aliases. Implement case-insensitive matching and handle conflicts. Add validation to ensure unique aliases across all shows.",
            "status": "pending",
            "testStrategy": "Test alias resolution with various inputs including exact matches, case variations, conflicts, and non-existent aliases. Verify primary name and alias lookups work correctly."
          },
          {
            "id": 3,
            "title": "Create CUE file detection and pattern matching logic",
            "description": "Implement logic to resolve CUE files based on patterns, direct mappings, and date-based selection including finding the most recent file",
            "dependencies": [
              1
            ],
            "details": "Create internal/shows/cue_resolver.go with methods ResolveCueFile(showCfg *config.ShowConfig, baseDir string) (string, error) and findLatestFile(files []string) string. Support direct file mapping (cue_file_mapping), glob pattern matching (cue_file_pattern), and intelligent latest file selection based on modification time or filename parsing. Handle missing files gracefully with clear error messages.",
            "status": "pending",
            "testStrategy": "Mock filesystem operations to test pattern matching, latest file selection, and error cases. Test with various file patterns and directory structures."
          },
          {
            "id": 4,
            "title": "Integrate templating system with per-show template selection",
            "description": "Extend the formatter to support template definitions and enable per-show template selection with variable substitution",
            "dependencies": [
              1
            ],
            "details": "Enhance internal/formatter/formatter.go to add TemplateFormatter struct supporting Go text/template syntax. Implement SelectTemplate(showCfg *config.ShowConfig) *template.Template that chooses between referenced templates, custom inline templates, or defaults. Support variables like {{.Time}}, {{.Title}}, {{.Artist}}, {{.ShowTitle}}, {{.ShowDate}}, {{.TrackCount}}. Add template caching for performance.",
            "status": "pending",
            "testStrategy": "Test template rendering with various formats, variable substitutions, and edge cases like missing fields. Verify template selection logic and custom template overrides."
          },
          {
            "id": 5,
            "title": "Refactor CLI to single-command interface with optional show selection",
            "description": "Transform the command-line interface to use config file as primary argument with optional show-specific processing",
            "dependencies": [
              1,
              2
            ],
            "details": "Rewrite cmd/mixcloud-updater/main.go to support './mixcloud-updater config.toml' as primary usage. Add -show flag for specific show processing by name/alias. Implement single positional argument support for config file. Remove old -cue-file and -show-name flags. Add better help text explaining the new usage patterns. Maintain -dry-run and other utility flags.",
            "status": "pending",
            "testStrategy": "Test CLI argument parsing with various combinations: no args, config only, config with show alias, dry-run mode. Verify error handling for missing configs."
          },
          {
            "id": 6,
            "title": "Build ShowProcessor for batch and individual show processing",
            "description": "Create the core processor that handles both single show and batch processing with proper orchestration and error handling",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Implement internal/processor/show_processor.go with ShowProcessor struct containing ProcessShow(nameOrAlias string, dryRun bool) error and ProcessAllShows(dryRun bool) error methods. Include show name generation with date substitution, template selection, CUE file resolution, and Mixcloud API integration. Implement priority-based processing order for batch operations. Add progress reporting for batch processing.",
            "status": "pending",
            "testStrategy": "Mock all dependencies (CUE parser, Mixcloud client, formatter) to test processing logic. Test both single show and batch processing scenarios with various configurations."
          },
          {
            "id": 7,
            "title": "Add comprehensive error handling, logging, and batch reporting",
            "description": "Implement robust error handling for all failure scenarios with detailed logging and batch processing reports",
            "dependencies": [
              6
            ],
            "details": "Add structured logging using log/slog or similar. Implement error aggregation for batch processing to continue on individual failures. Create ProcessingReport struct to track successes, failures, and skipped shows. Add detailed error context including which show failed, why, and recovery suggestions. Implement retry logic for transient failures. Output summary report after batch processing.",
            "status": "pending",
            "testStrategy": "Test error scenarios including missing CUE files, API failures, template errors, and config issues. Verify batch processing continues on individual failures and produces accurate reports."
          },
          {
            "id": 8,
            "title": "Create comprehensive tests and update documentation",
            "description": "Write unit tests for all new components, integration tests for the full workflow, and update all documentation to reflect the new architecture",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Create unit tests for config loading, alias resolution, CUE file detection, template rendering, and show processing. Write integration tests simulating full workflows with sample configs and CUE files. Update README.md with new usage examples, configuration guide, and migration instructions. Update CLAUDE.md with new architecture details. Create example config.toml with multiple show configurations as reference.",
            "status": "pending",
            "testStrategy": "Achieve >80% test coverage for new code. Include table-driven tests for various scenarios. Create end-to-end tests with real config files and mock Mixcloud responses."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement enhanced configuration validator with startup validation and --validate-only mode",
        "description": "Create a comprehensive configuration validation system that automatically runs on startup to validate show configurations, template syntax, file paths, and OAuth settings, categorizing issues as critical errors or warnings",
        "details": "Implement a validation package in internal/validator/:\n\n```go\ntype Validator struct {\n    config *config.Config\n    errors []ValidationIssue\n    warnings []ValidationIssue\n}\n\ntype ValidationIssue struct {\n    Category string  // \"config\", \"oauth\", \"template\", \"filesystem\"\n    Field    string  // specific config field\n    Message  string  // user-friendly error message\n    Suggestion string // actionable fix suggestion\n    Critical bool    // true = blocks execution\n}\n\nfunc NewValidator(cfg *config.Config) *Validator {\n    return &Validator{config: cfg}\n}\n\nfunc (v *Validator) Validate() error {\n    v.validateOAuthSettings()\n    v.validateShowConfigurations()\n    v.validateTemplates()\n    v.validateFilePaths()\n    v.validateFilteringRules()\n    \n    if len(v.errors) > 0 {\n        return v.formatValidationReport()\n    }\n    return nil\n}\n\nfunc (v *Validator) validateOAuthSettings() {\n    if v.config.OAuth.ClientID == \"\" {\n        v.addError(\"oauth\", \"client_id\", \"OAuth client ID is missing\", \"Add 'client_id' to [oauth] section\")\n    }\n    if v.config.OAuth.ClientSecret == \"\" {\n        v.addError(\"oauth\", \"client_secret\", \"OAuth client secret is missing\", \"Add 'client_secret' to [oauth] section\")\n    }\n    // Test token validity if present\n    if v.config.OAuth.AccessToken != \"\" {\n        if err := v.testTokenValidity(); err != nil {\n            v.addWarning(\"oauth\", \"access_token\", \"Access token may be expired\", \"Run with --dry-run to refresh token\")\n        }\n    }\n}\n\nfunc (v *Validator) validateShowConfigurations() {\n    for name, show := range v.config.Shows {\n        // Validate show URLs\n        if show.MixcloudURL != \"\" {\n            if !isValidMixcloudURL(show.MixcloudURL) {\n                v.addError(\"shows\", name+\".mixcloud_url\", \"Invalid Mixcloud URL format\", \"Use format: https://www.mixcloud.com/username/show-slug/\")\n            }\n        }\n        \n        // Validate CUE file patterns\n        if show.CueFilePattern != \"\" {\n            if _, err := regexp.Compile(show.CueFilePattern); err != nil {\n                v.addError(\"shows\", name+\".cue_file_pattern\", \"Invalid regex pattern\", \"Check regex syntax: \"+err.Error())\n            }\n        }\n        \n        // Validate template references\n        if show.Template != \"\" && v.config.Templates[show.Template] == nil {\n            v.addError(\"shows\", name+\".template\", fmt.Sprintf(\"Template '%s' not found\", show.Template), \"Define template in [templates] section or use 'default'\")\n        }\n    }\n}\n\nfunc (v *Validator) validateTemplates() {\n    for name, tmpl := range v.config.Templates {\n        // Parse and validate Go template syntax\n        t := template.New(name)\n        if tmpl.Header != \"\" {\n            if _, err := t.Parse(tmpl.Header); err != nil {\n                v.addError(\"templates\", name+\".header\", \"Invalid template syntax in header\", \"Fix syntax error: \"+err.Error())\n            }\n        }\n        if tmpl.TrackLine != \"\" {\n            if _, err := t.Parse(tmpl.TrackLine); err != nil {\n                v.addError(\"templates\", name+\".track_line\", \"Invalid template syntax in track_line\", \"Fix syntax error: \"+err.Error())\n            }\n        }\n        if tmpl.Footer != \"\" {\n            if _, err := t.Parse(tmpl.Footer); err != nil {\n                v.addError(\"templates\", name+\".footer\", \"Invalid template syntax in footer\", \"Fix syntax error: \"+err.Error())\n            }\n        }\n    }\n}\n\nfunc (v *Validator) validateFilePaths() {\n    // Check CUE file directory\n    if v.config.Processing.CueFileDirectory != \"\" {\n        if _, err := os.Stat(v.config.Processing.CueFileDirectory); os.IsNotExist(err) {\n            v.addError(\"processing\", \"cue_file_directory\", \"CUE file directory does not exist\", \"Create directory or fix path: \"+v.config.Processing.CueFileDirectory)\n        }\n    }\n    \n    // Check for any hardcoded paths in show configs\n    for name, show := range v.config.Shows {\n        if show.CueFilePath != \"\" {\n            if _, err := os.Stat(show.CueFilePath); os.IsNotExist(err) {\n                v.addWarning(\"shows\", name+\".cue_file_path\", \"Specified CUE file not found\", \"File will be skipped: \"+show.CueFilePath)\n            }\n        }\n    }\n}\n\nfunc (v *Validator) validateFilteringRules() {\n    // Compile and test regex patterns\n    for i, pattern := range v.config.Filtering.ExcludedArtistPatterns {\n        if _, err := regexp.Compile(pattern); err != nil {\n            v.addError(\"filtering\", fmt.Sprintf(\"excluded_artist_patterns[%d]\", i), \"Invalid regex pattern\", \"Fix pattern syntax: \"+err.Error())\n        }\n    }\n    for i, pattern := range v.config.Filtering.ExcludedTitlePatterns {\n        if _, err := regexp.Compile(pattern); err != nil {\n            v.addError(\"filtering\", fmt.Sprintf(\"excluded_title_patterns[%d]\", i), \"Invalid regex pattern\", \"Fix pattern syntax: \"+err.Error())\n        }\n    }\n}\n```\n\nIntegrate with main.go:\n\n```go\nfunc main() {\n    validateOnly := flag.Bool(\"validate-only\", false, \"Validate configuration without processing\")\n    flag.Parse()\n    \n    // Load config\n    cfg, err := config.Load(*configFile)\n    if err != nil {\n        log.Fatal(\"Failed to load config: \", err)\n    }\n    \n    // Always validate on startup\n    validator := validator.NewValidator(cfg)\n    if err := validator.Validate(); err != nil {\n        fmt.Fprintf(os.Stderr, \"%s\\n\", err)\n        if validator.HasCriticalErrors() {\n            os.Exit(1)\n        }\n        // Continue with warnings\n        fmt.Fprintln(os.Stderr, \"Continuing with warnings...\")\n    }\n    \n    if *validateOnly {\n        if validator.HasIssues() {\n            fmt.Println(\"Configuration has issues (see above)\")\n            os.Exit(1)\n        }\n        fmt.Println(\"Configuration is valid!\")\n        os.Exit(0)\n    }\n    \n    // Continue with normal processing...\n}\n```\n\nFormat validation output with color coding:\n\n```go\nfunc (v *Validator) formatValidationReport() error {\n    var report strings.Builder\n    \n    if len(v.errors) > 0 {\n        report.WriteString(\"\\n🚫 CRITICAL ERRORS (must fix):\\n\")\n        for _, err := range v.errors {\n            report.WriteString(fmt.Sprintf(\"  ❌ [%s] %s: %s\\n\", err.Category, err.Field, err.Message))\n            if err.Suggestion != \"\" {\n                report.WriteString(fmt.Sprintf(\"     💡 %s\\n\", err.Suggestion))\n            }\n        }\n    }\n    \n    if len(v.warnings) > 0 {\n        report.WriteString(\"\\n⚠️  WARNINGS (optional fixes):\\n\")\n        for _, warn := range v.warnings {\n            report.WriteString(fmt.Sprintf(\"  ⚠️  [%s] %s: %s\\n\", warn.Category, warn.Field, warn.Message))\n            if warn.Suggestion != \"\" {\n                report.WriteString(fmt.Sprintf(\"     💡 %s\\n\", warn.Suggestion))\n            }\n        }\n    }\n    \n    return fmt.Errorf(report.String())\n}\n```",
        "testStrategy": "Create comprehensive test suite for validator:\n\n1. **Critical Error Tests:**\n   - Test with missing OAuth credentials\n   - Test with invalid Mixcloud URLs\n   - Test with non-existent file paths\n   - Test with malformed regex patterns\n   - Verify execution is blocked for critical errors\n\n2. **Warning Tests:**\n   - Test with expired OAuth tokens\n   - Test with missing optional CUE files\n   - Test with deprecated config options\n   - Verify execution continues with warnings\n\n3. **Template Validation Tests:**\n   - Test with invalid Go template syntax\n   - Test with undefined template variables\n   - Test with circular template references\n   - Verify clear error messages for template issues\n\n4. **--validate-only Mode Tests:**\n   - Test that no processing occurs in validate-only mode\n   - Test exit codes (0 for valid, 1 for issues)\n   - Test output formatting for different issue types\n   - Verify all config sections are validated\n\n5. **Integration Tests:**\n   - Test with real config files from examples\n   - Test with progressively complex configurations\n   - Test error message clarity and suggestions\n   - Verify startup validation doesn't impact performance",
        "status": "pending",
        "dependencies": [
          2,
          11,
          12
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create validation framework with error types and reporting structures",
            "description": "Set up the core validation package structure with ValidationIssue types, Validator struct, and error/warning collection mechanisms",
            "dependencies": [],
            "details": "Create internal/validator/validator.go with Validator struct containing config reference and issue slices. Define ValidationIssue struct with Category, Field, Message, Suggestion, and Critical fields. Implement helper methods addError(), addWarning(), HasCriticalErrors(), HasIssues(), and formatValidationReport() with color-coded output formatting",
            "status": "pending",
            "testStrategy": "Unit test error/warning collection, verify formatValidationReport output formatting, test issue categorization logic"
          },
          {
            "id": 2,
            "title": "Implement basic configuration validation for OAuth and filesystem paths",
            "description": "Build validation methods for OAuth settings, station configuration, and filesystem paths including directory existence checks",
            "dependencies": [
              1
            ],
            "details": "Implement validateOAuthSettings() to check ClientID, ClientSecret, and optionally test token validity. Create validateFilePaths() to verify CueFileDirectory exists and check hardcoded CUE file paths in show configs. Add validateStationSettings() for basic station config validation. Use os.Stat for file system checks",
            "status": "pending",
            "testStrategy": "Mock filesystem for path validation tests, test OAuth validation with missing/invalid credentials, verify appropriate error/warning categorization"
          },
          {
            "id": 3,
            "title": "Build show configuration validation with Mixcloud URL and CUE pattern checks",
            "description": "Implement comprehensive validation for show configurations including URL format validation, regex pattern compilation, and template reference checks",
            "dependencies": [
              1
            ],
            "details": "Create validateShowConfigurations() iterating through all show configs. Implement isValidMixcloudURL() helper to verify URL format matches https://www.mixcloud.com/username/show-slug/. Compile and validate CueFilePattern regex patterns. Check template references exist in config.Templates map. Generate specific error messages with field paths like 'shows.showname.mixcloud_url'",
            "status": "pending",
            "testStrategy": "Test with various valid/invalid Mixcloud URLs, malformed regex patterns, missing template references, verify error messages include correct field paths"
          },
          {
            "id": 4,
            "title": "Add template syntax validation for Go templates and filtering rules",
            "description": "Validate Go template syntax in headers, track lines, and footers, plus validate regex patterns in filtering rules",
            "dependencies": [
              1
            ],
            "details": "Implement validateTemplates() using Go's text/template parser to validate Header, TrackLine, and Footer template syntax. Create validateFilteringRules() to compile and test all regex patterns in ExcludedArtistPatterns and ExcludedTitlePatterns arrays. Capture template parse errors and regex compile errors with helpful context",
            "status": "pending",
            "testStrategy": "Test with invalid Go template syntax, malformed regex patterns, verify error messages include specific syntax errors"
          },
          {
            "id": 5,
            "title": "Integrate validator into main application startup flow",
            "description": "Modify main.go to instantiate validator on startup, run validation before processing, and handle critical errors vs warnings appropriately",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update main() to create validator.NewValidator(cfg) after config load. Call Validate() and check for errors. If HasCriticalErrors(), print report to stderr and exit(1). For warnings only, print to stderr with 'Continuing with warnings...' message. Ensure validation runs before any CUE file processing or API calls",
            "status": "pending",
            "testStrategy": "Integration test with configs containing critical errors, warnings only, and clean configs. Verify appropriate exit codes and stderr output"
          },
          {
            "id": 6,
            "title": "Implement validate-only CLI mode and comprehensive test suite",
            "description": "Add --validate-only flag for configuration testing without processing, and create comprehensive unit and integration tests for all validation scenarios",
            "dependencies": [
              5
            ],
            "details": "Add validateOnly bool flag to CLI parsing. When set, run validation and exit with appropriate code (0 for valid, 1 for issues) with clear success/failure message. Create validator_test.go with table-driven tests covering all validation methods, edge cases, and error formatting. Test validate-only mode integration",
            "status": "pending",
            "testStrategy": "Test CLI with --validate-only flag, verify exit codes match validation results, test all validation categories with comprehensive test cases"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-29T19:16:03.127Z",
      "updated": "2025-06-30T04:01:57.153Z",
      "description": "Tasks for master context"
    }
  }
}