// Package cue provides parsing functionality for standard CUE sheet format files
// generated by Myriad play-out software. It extracts track metadata including
// artist, title, and timing information.
package cue

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
	"unicode/utf8"
)

// AIDEV-TODO: Implement CUE file line-by-line parsing
// AIDEV-TODO: Handle TRACK, PERFORMER, TITLE, and INDEX commands
// AIDEV-TODO: Parse album-level metadata and REM commands
// AIDEV-NOTE: CUE format varies by software - Myriad has specific quirks

// Track represents a single track from a CUE sheet
type Track struct {
	Index     int    `json:"index"`     // Track number (e.g., 1, 2, 3)
	StartTime string `json:"start_time"` // Start time in MM:SS format
	Artist    string `json:"artist"`    // Track artist/performer
	Title     string `json:"title"`     // Track title
	Genre     string `json:"genre"`     // Track genre (if available)
}

// String returns a formatted string representation of the track for debugging
// AIDEV-NOTE: Useful for logging and troubleshooting parsing issues
func (t Track) String() string {
	if t.Genre != "" {
		return fmt.Sprintf("Track %d [%s]: %s - %s (%s)", t.Index, t.StartTime, t.Artist, t.Title, t.Genre)
	}
	return fmt.Sprintf("Track %d [%s]: %s - %s", t.Index, t.StartTime, t.Artist, t.Title)
}

// IsEmpty returns true if the track has no meaningful content
func (t Track) IsEmpty() bool {
	return strings.TrimSpace(t.Artist) == "" && strings.TrimSpace(t.Title) == ""
}

// CueSheet represents the complete parsed CUE file
type CueSheet struct {
	Title     string   `json:"title"`      // Album/show title
	Date      string   `json:"date"`       // Album/show date
	Performer string   `json:"performer"`  // Album/show performer/artist
	Genre     string   `json:"genre"`      // Album/show genre
	Files     []string `json:"files"`      // Referenced audio files
	Tracks    []Track  `json:"tracks"`     // List of tracks in the CUE sheet
}

// String returns a formatted string representation of the CueSheet for debugging
func (c CueSheet) String() string {
	var sb strings.Builder
	if c.Title != "" {
		sb.WriteString(fmt.Sprintf("CueSheet: %s", c.Title))
	} else {
		sb.WriteString("CueSheet: (untitled)")
	}
	if c.Date != "" {
		sb.WriteString(fmt.Sprintf(" (%s)", c.Date))
	}
	sb.WriteString(fmt.Sprintf(" - %d tracks", len(c.Tracks)))
	return sb.String()
}

// GetTrackCount returns the number of tracks in the CueSheet
func (c CueSheet) GetTrackCount() int {
	return len(c.Tracks)
}

// GetTrackByIndex returns a track by its index number, or nil if not found
// AIDEV-NOTE: Index is 1-based to match CUE file numbering
func (c CueSheet) GetTrackByIndex(index int) *Track {
	for _, track := range c.Tracks {
		if track.Index == index {
			return &track
		}
	}
	return nil
}

// CueCommand represents different types of CUE file commands
type CueCommand int

const (
	CmdUnknown CueCommand = iota
	CmdRem        // REM comment or metadata
	CmdFile       // FILE reference  
	CmdTrack      // TRACK definition
	CmdPerformer  // PERFORMER (artist)
	CmdTitle      // TITLE
	CmdIndex      // INDEX timing
)

// ParsedLine represents a parsed line from a CUE file
type ParsedLine struct {
	Command CueCommand
	Args    []string
	Raw     string
	LineNum int
}

// lineParser handles reading and parsing CUE files line by line
type lineParser struct {
	file    *os.File
	scanner *bufio.Scanner
	lineNum int
}

// AIDEV-NOTE: BOM (Byte Order Mark) detection is important for Windows-generated CUE files
var bomUtf8 = []byte{0xEF, 0xBB, 0xBF}

// newLineParser creates a new line parser for the given file
func newLineParser(filename string) (*lineParser, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to open CUE file: %w", err)
	}

	scanner := bufio.NewScanner(file)

	return &lineParser{
		file:    file,
		scanner: scanner,
		lineNum: 0,
	}, nil
}

// Close closes the file and releases resources
func (p *lineParser) Close() error {
	if p.file != nil {
		return p.file.Close()
	}
	return nil
}

// AIDEV-NOTE: Regex patterns for parsing different CUE commands
var (
	// Matches quoted strings, handling escaped quotes
	quotedStringRegex = regexp.MustCompile(`"([^"\\]*(\\.[^"\\]*)*)"`)
	
	// Matches INDEX command: INDEX 01 MM:SS:FF
	indexRegex = regexp.MustCompile(`^INDEX\s+(\d+)\s+(\d+):(\d+):(\d+)$`)
	
	// Matches TRACK command: TRACK 01 AUDIO
	trackRegex = regexp.MustCompile(`^TRACK\s+(\d+)\s+(.+)$`)
)

// parseLine parses a single line and returns the command type and arguments
// AIDEV-NOTE: Handles quoted strings and various CUE command formats
func (p *lineParser) parseLine(line string) ParsedLine {
	p.lineNum++
	
	// Trim whitespace and handle empty lines
	trimmed := strings.TrimSpace(line)
	if trimmed == "" {
		return ParsedLine{
			Command: CmdUnknown,
			Args:    []string{},
			Raw:     line,
			LineNum: p.lineNum,
		}
	}

	// Convert to uppercase for command matching (CUE commands are case-insensitive)
	upper := strings.ToUpper(trimmed)
	
	var command CueCommand
	var args []string

	// Parse different command types
	switch {
	case strings.HasPrefix(upper, "REM "):
		command = CmdRem
		args = parseLineArgs(trimmed[4:]) // Skip "REM "
		
	case strings.HasPrefix(upper, "FILE "):
		command = CmdFile
		args = parseLineArgs(trimmed[5:]) // Skip "FILE "
		
	case strings.HasPrefix(upper, "TRACK "):
		command = CmdTrack
		if matches := trackRegex.FindStringSubmatch(upper); matches != nil {
			args = []string{matches[1], matches[2]} // Track number, format
		} else {
			args = parseLineArgs(trimmed[6:]) // Fallback parsing
		}
		
	case strings.HasPrefix(upper, "PERFORMER "):
		command = CmdPerformer
		args = parseLineArgs(trimmed[10:]) // Skip "PERFORMER "
		
	case strings.HasPrefix(upper, "TITLE "):
		command = CmdTitle
		args = parseLineArgs(trimmed[6:]) // Skip "TITLE "
		
	case strings.HasPrefix(upper, "INDEX "):
		command = CmdIndex
		if matches := indexRegex.FindStringSubmatch(upper); matches != nil {
			args = []string{matches[1], matches[2], matches[3], matches[4]} // Index, MM, SS, FF
		} else {
			args = parseLineArgs(trimmed[6:]) // Fallback parsing
		}
		
	default:
		command = CmdUnknown
		args = parseLineArgs(trimmed)
	}

	return ParsedLine{
		Command: command,
		Args:    args,
		Raw:     line,
		LineNum: p.lineNum,
	}
}

// parseLineArgs parses arguments from a line, handling quoted strings properly
// AIDEV-NOTE: CUE files often have quoted strings with spaces in titles/artists
func parseLineArgs(argString string) []string {
	if argString == "" {
		return []string{}
	}
	
	// First, extract quoted strings
	quotedMatches := quotedStringRegex.FindAllStringSubmatch(argString, -1)
	quotedStrings := make(map[string]string)
	
	// Replace quoted strings with placeholders to simplify parsing
	processedString := argString
	for i, match := range quotedMatches {
		placeholder := fmt.Sprintf("__QUOTED_%d__", i)
		quotedStrings[placeholder] = match[1] // The content inside quotes
		processedString = strings.Replace(processedString, match[0], placeholder, 1)
	}
	
	// Split on whitespace
	parts := strings.Fields(processedString)
	
	// Restore quoted strings
	for i, part := range parts {
		if quotedContent, isQuoted := quotedStrings[part]; isQuoted {
			parts[i] = quotedContent
		}
	}
	
	return parts
}

// nextLine reads the next line from the file
func (p *lineParser) nextLine() (ParsedLine, bool) {
	if !p.scanner.Scan() {
		return ParsedLine{}, false
	}
	
	line := p.scanner.Text()
	
	// Handle BOM on first line if present
	// AIDEV-NOTE: BOM is 3 bytes but when converted to string it's 3 runes
	if p.lineNum == 0 && len(line) >= 3 {
		// Check for UTF-8 BOM at start of file
		if utf8.ValidString(line) {
			runes := []rune(line)
			if len(runes) >= 1 && runes[0] == '\uFEFF' {
				// Strip the BOM character
				line = string(runes[1:])
			}
		}
	}
	
	return p.parseLine(line), true
}

// hasError returns true if the scanner encountered an error
func (p *lineParser) hasError() error {
	return p.scanner.Err()
}

// trackParser maintains state while parsing track information
type trackParser struct {
	currentTrack    *Track
	tracks          []Track
	albumPerformer  string
	albumTitle      string
	albumDate       string
	albumGenre      string
	files           []string
	inTrackSection  bool // true after first TRACK command
}

// newTrackParser creates a new track parser
func newTrackParser() *trackParser {
	return &trackParser{
		tracks:         []Track{},
		files:          []string{},
		inTrackSection: false,
	}
}

// processLine processes a parsed line and updates track information
// AIDEV-NOTE: Handles both album-level and track-level metadata
func (tp *trackParser) processLine(line ParsedLine) error {
	switch line.Command {
	case CmdTrack:
		return tp.handleTrackCommand(line)
	case CmdPerformer:
		return tp.handlePerformerCommand(line)
	case CmdTitle:
		return tp.handleTitleCommand(line)
	case CmdIndex:
		return tp.handleIndexCommand(line)
	case CmdFile:
		return tp.handleFileCommand(line)
	case CmdRem:
		return tp.handleRemCommand(line)
	}
	return nil
}

// handleTrackCommand processes TRACK commands and starts a new track
func (tp *trackParser) handleTrackCommand(line ParsedLine) error {
	// Finalize current track if one exists
	if tp.currentTrack != nil {
		tp.finalizeCurrentTrack()
	}

	if len(line.Args) < 2 {
		return fmt.Errorf("line %d: TRACK command requires track number and format", line.LineNum)
	}

	trackNum, err := strconv.Atoi(line.Args[0])
	if err != nil {
		return fmt.Errorf("line %d: invalid track number '%s'", line.LineNum, line.Args[0])
	}

	// Create new track
	tp.currentTrack = &Track{
		Index: trackNum,
		// Inherit album-level metadata as defaults
		Artist: tp.albumPerformer,
		Title:  "", // Title will be set by TITLE command
		Genre:  "",
	}

	tp.inTrackSection = true
	return nil
}

// handlePerformerCommand processes PERFORMER commands
func (tp *trackParser) handlePerformerCommand(line ParsedLine) error {
	if len(line.Args) == 0 {
		return fmt.Errorf("line %d: PERFORMER command requires artist name", line.LineNum)
	}

	performer := strings.Join(line.Args, " ")

	if tp.inTrackSection && tp.currentTrack != nil {
		// Track-level performer
		tp.currentTrack.Artist = performer
	} else {
		// Album-level performer (before any TRACK commands)
		tp.albumPerformer = performer
	}

	return nil
}

// handleTitleCommand processes TITLE commands
func (tp *trackParser) handleTitleCommand(line ParsedLine) error {
	if len(line.Args) == 0 {
		return fmt.Errorf("line %d: TITLE command requires title text", line.LineNum)
	}

	title := strings.Join(line.Args, " ")

	if tp.inTrackSection && tp.currentTrack != nil {
		// Track-level title
		tp.currentTrack.Title = title
	} else {
		// Album-level title (before any TRACK commands)
		tp.albumTitle = title
	}

	return nil
}

// handleIndexCommand processes INDEX commands and converts time format
// AIDEV-NOTE: Converts MM:SS:FF format to MM:SS by dropping frames
func (tp *trackParser) handleIndexCommand(line ParsedLine) error {
	if tp.currentTrack == nil {
		return fmt.Errorf("line %d: INDEX command found outside of track context", line.LineNum)
	}

	if len(line.Args) < 4 {
		return fmt.Errorf("line %d: INDEX command requires index number and time (MM:SS:FF)", line.LineNum)
	}

	indexNum, err := strconv.Atoi(line.Args[0])
	if err != nil {
		return fmt.Errorf("line %d: invalid index number '%s'", line.LineNum, line.Args[0])
	}

	// Only process INDEX 01 (track start time)
	if indexNum != 1 {
		return nil
	}

	// Parse time components
	minutes, err := strconv.Atoi(line.Args[1])
	if err != nil {
		return fmt.Errorf("line %d: invalid minutes '%s'", line.LineNum, line.Args[1])
	}

	seconds, err := strconv.Atoi(line.Args[2])
	if err != nil {
		return fmt.Errorf("line %d: invalid seconds '%s'", line.LineNum, line.Args[2])
	}

	// Convert to MM:SS format (dropping frames)
	tp.currentTrack.StartTime = fmt.Sprintf("%02d:%02d", minutes, seconds)

	return nil
}

// handleFileCommand processes FILE commands for audio file references
// AIDEV-NOTE: CUE files can reference single or multiple audio files
func (tp *trackParser) handleFileCommand(line ParsedLine) error {
	if len(line.Args) < 2 {
		return fmt.Errorf("line %d: FILE command requires filename and format", line.LineNum)
	}

	filename := line.Args[0]
	format := strings.ToUpper(line.Args[1])

	// Store the filename (removing quotes if present)
	filename = strings.Trim(filename, "\"")
	tp.files = append(tp.files, filename)

	// AIDEV-NOTE: Common formats include WAVE, MP3, FLAC, BINARY
	// We don't need to validate format here, just store the reference
	_ = format

	return nil
}

// handleRemCommand processes REM commands for additional metadata
// AIDEV-NOTE: REM commands provide extended metadata not in standard CUE spec
func (tp *trackParser) handleRemCommand(line ParsedLine) error {
	if len(line.Args) < 1 {
		return nil // Skip empty REM commands
	}

	remType := strings.ToUpper(line.Args[0])
	var value string
	if len(line.Args) > 1 {
		value = strings.Join(line.Args[1:], " ")
	}

	switch remType {
	case "GENRE":
		if tp.inTrackSection && tp.currentTrack != nil {
			// Track-level genre
			tp.currentTrack.Genre = value
		} else {
			// Album-level genre
			tp.albumGenre = value
		}
	case "DATE":
		if !tp.inTrackSection {
			tp.albumDate = value
		}
	case "COMMENT":
		// Skip comments - they're just metadata
		return nil
	default:
		// AIDEV-NOTE: Other REM types like DISCID, CATALOG, etc. are ignored
		// Could be expanded in the future if needed
		return nil
	}

	return nil
}

// finalizeCurrentTrack adds the current track to the tracks list
func (tp *trackParser) finalizeCurrentTrack() {
	if tp.currentTrack != nil {
		// Only add tracks that have meaningful content
		if !tp.currentTrack.IsEmpty() {
			tp.tracks = append(tp.tracks, *tp.currentTrack)
		}
	}
}

// finish finalizes parsing and returns the complete CueSheet
func (tp *trackParser) finish() *CueSheet {
	// Finalize the last track
	tp.finalizeCurrentTrack()

	return &CueSheet{
		Title:     tp.albumTitle,
		Date:      tp.albumDate,
		Performer: tp.albumPerformer,
		Genre:     tp.albumGenre,
		Files:     tp.files,
		Tracks:    tp.tracks,
	}
}

// ParseCueFile parses a CUE file and returns a CueSheet with track information
// AIDEV-NOTE: Main entry point for CUE file parsing - orchestrates the entire process
func ParseCueFile(filename string) (*CueSheet, error) {
	// Open and initialize the line parser
	parser, err := newLineParser(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to open CUE file '%s': %w", filename, err)
	}
	defer func() {
		if closeErr := parser.Close(); closeErr != nil {
			// AIDEV-NOTE: Log the close error but don't override the main error
			_ = closeErr
		}
	}()

	// Initialize the track parser
	trackParser := newTrackParser()

	// Process the file line by line
	for {
		line, hasMore := parser.nextLine()
		if !hasMore {
			break
		}

		// Process the parsed line
		if err := trackParser.processLine(line); err != nil {
			return nil, fmt.Errorf("parsing error in '%s': %w", filename, err)
		}
	}

	// Check for scanner errors
	if err := parser.hasError(); err != nil {
		return nil, fmt.Errorf("error reading CUE file '%s': %w", filename, err)
	}

	// Finalize parsing and get the result
	cueSheet := trackParser.finish()

	// Validate the parsed result
	if err := validateCueSheet(cueSheet); err != nil {
		return nil, fmt.Errorf("validation failed for '%s': %w", filename, err)
	}

	return cueSheet, nil
}

// validateCueSheet performs basic validation on the parsed CueSheet
// AIDEV-NOTE: Ensures the parsed data makes sense before returning to caller
func validateCueSheet(cueSheet *CueSheet) error {
	if cueSheet == nil {
		return fmt.Errorf("parsed CueSheet is nil")
	}

	// Check if we have any tracks
	if len(cueSheet.Tracks) == 0 {
		return fmt.Errorf("CUE file contains no valid tracks")
	}

	// Validate individual tracks
	for i, track := range cueSheet.Tracks {
		if track.Index <= 0 {
			return fmt.Errorf("track %d has invalid index: %d", i+1, track.Index)
		}

		if track.IsEmpty() {
			return fmt.Errorf("track %d (%d) has no artist or title", i+1, track.Index)
		}

		// Validate start time format if present
		if track.StartTime != "" {
			if !isValidTimeFormat(track.StartTime) {
				return fmt.Errorf("track %d (%d) has invalid time format: %s", i+1, track.Index, track.StartTime)
			}
		}
	}

	return nil
}

// isValidTimeFormat checks if a time string is in MM:SS format
func isValidTimeFormat(timeStr string) bool {
	// Basic regex for MM:SS format
	timeRegex := regexp.MustCompile(`^\d{1,3}:\d{2}$`)
	return timeRegex.MatchString(timeStr)
}